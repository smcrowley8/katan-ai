<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>katan_ai.katan.board.board API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>katan_ai.katan.board.board</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from itertools import product
from typing import Dict, FrozenSet, Optional, Set

from ..errors import (
    CoordsBlockedError,
    InvalidCoordsError,
    NotConnectedError,
    RequiresSettlementError,
    TooCloseToBuildingError,
)
from ..player import Player
from ..resource import Resource
from ..roll_yield import RollYield, RollYieldSource
from .building import PathBuilding
from .building_type import BuildingType
from .coords import Coords
from .harbor import Harbor
from .hex import Hex
from .hex_type import HexType
from .intersection import Intersection
from .intersection_building import IntersectionBuilding
from .path import Path


class Board:
    &#34;&#34;&#34;An interface for holding the state of Catan boards.

    Uses a triangular grid to hold the tiles, intersections and
    paths. The Board constructor will automatically
    generate the intersections and paths from a dict of hexes,
    assuming all the hexes tile correctly.

    Args:
        hexes:
            The hexes on the board, keyed by their coordinates
        harbors:
            The harbors on the board
        robber:
            The initial coordinates of the robber. If None, then will automatically place the robber on the first
            desert hex it can find, and raise an error if there are non

    Attributes:
        hexes (Dict[Coord, Hex]):
            The hexes on this catan board, keyed by their coordinates
        intersections: (Dict[Coords, Intersection]):
            The intersections on the board, keyed by their coordinates
        paths (Dict[frozenset[Coords], Path]):
            The paths on the board, keyed by the coordinates of the two intersections they connect
        harbors (Dict[frozenset[Coords], Harbor]):
            The harbors on the board, keyed by the coords of the path they are attached to
        robber (Set[Coords]): The location of the robber
    &#34;&#34;&#34;

    def __init__(
        self, hexes: Set[Hex], harbors: Set[Harbor] = set(), robber: Coords = None
    ):
        self.hexes: Dict[Coords, Hex] = dict(zip((h.coords for h in hexes), hexes))
        self.harbors = {frozenset(h.path_coords): h for h in harbors}
        # Position the robber on the desert
        if robber:
            self.robber = robber
        else:
            self.robber = [
                h.coords for h in self.hexes.values() if h.hex_type == HexType.DESERT
            ][0]
        # Gather the points around each hex into a set
        intersection_coords = set(
            map(
                lambda x: x[0] + x[1],
                list(product(*[self.hexes.keys(), Hex.CONNECTED_CORNER_OFFSETS])),
            )
        )
        # Add the intersections to self.intersections
        self.intersections = {}
        for coords in intersection_coords:
            self.intersections[coords] = Intersection(coords)
        # Now add all the edges in between the intersections we just added
        self.paths = {}
        for c in self.intersections:
            for offset in Intersection.CONNECTED_CORNER_OFFSETS:
                coord = c + offset
                if coord in self.intersections:
                    self.paths[frozenset([c, c + offset])] = Path(set([c, c + offset]))

    def add_path_building(
        self,
        player: Player,
        building_type: BuildingType,
        path_coords: Set[Coords],
        ensure_connected: Optional[bool] = True,
    ):
        &#34;&#34;&#34;Add an path building to the board.

        Do not check if the player has enough resources, or any other checks other than the building&#39;s location being valid.

        Args:
            player: The player adding the building
            building_type: The building_type of the building being added
            path_coords: The coordinates the path to build the building on (i.e. the coordinates of the two intersections the path connects)
            ensure_connected: Whether to ensure that the path building is connected to another building. Defaults to True
        Raises:
            ValueError: If the path_coords are not valid
            CoordsBlockedError: If there is already a building on the path
            NotConnectedError: If check_connection is true and the building is not connected to anything
        &#34;&#34;&#34;
        for c in path_coords:
            if c not in self.intersections.keys():
                raise ValueError(
                    &#34;Invalid path: Paths must connect two intersections on the board. %s is not a intersection&#34;
                    % c
                )

        if frozenset(path_coords) not in self.paths.keys():
            raise ValueError(&#34;Invalid path: Path does not exist&#34;)

        if building_type is BuildingType.ROAD:
            self.assert_valid_road_coords(player, path_coords, ensure_connected)

        # Add the building
        self.paths[frozenset(path_coords)].building = PathBuilding(
            player, path_coords=path_coords, building_type=building_type
        )

    def assert_valid_road_coords(
        self,
        player: Player,
        path_coords: Set[Coords],
        ensure_connected: Optional[bool] = True,
    ):
        &#34;&#34;&#34;Assert that a given edge is a valid place for the player to build a road.

        Args:
            player: The player
            path_coords: The coordinates of the two intersections connected by the path
            ensure_connected: Whether to assert that the path is connected to the player&#39;s existing roads or settlements
        &#34;&#34;&#34;
        path: Path = self.paths[frozenset(path_coords)]
        if path.building is not None:
            raise CoordsBlockedError(&#34;There is already a building on this path&#34;)

        if ensure_connected:
            # Check if it&#39;s connected to a intersection building
            valid_buildings = set(
                filter(
                    lambda b: b is not None and b.owner is player,
                    map(lambda c: self.intersections[c].building, path_coords),
                )
            )
            if len(valid_buildings) == 0:
                # Check if it&#39;s connected to another path building
                paths_connected = set()
                for coords in path_coords:
                    for c in self.get_intersection_connected_intersections(
                        self.intersections[coords]
                    ):
                        connected_path = self.paths[frozenset({coords, c.coords})]
                        # Check if there is an path building (i.e. a road) to be connected to here
                        if (
                            connected_path.building is not None
                            and connected_path.building.owner is player
                        ):
                            # Checks that we aren&#39;t going through an enemy building to be connected
                            building = self.intersections[coords].building
                            if building is None or building.owner is player:
                                paths_connected.add(path)

                if len(paths_connected) == 0:
                    raise NotConnectedError(
                        &#34;Road is not connected to any other building&#34;
                    )

    def add_intersection_building(
        self,
        player: Player,
        coords: Coords,
        building_type: BuildingType,
        ensure_connected: Optional[bool] = True,
    ):
        &#34;&#34;&#34;Add an intersection building to the board.

        Args:
            player: The player who owns the settlement
            coords: The coords to put the building
            ensure_connected: Whether to ensure that the building is connected to the player&#39;s roads. Defaults to True
        Raises:
            InvalidCoordsError: If coords is not a valid intersection
            TooCloseToBuildingError: If the building is too close to another building
            PositionAlreadyTakenError: If the position is already taken
        &#34;&#34;&#34;
        if building_type == BuildingType.SETTLEMENT:
            self.assert_valid_settlement_coords(coords, player, ensure_connected)
        elif building_type == BuildingType.CITY:
            self.assert_valid_city_coords(player=player, coords=coords)
        else:
            raise ValueError(
                &#34;Invalid building type passed to Board.add_intersection_building, received %s&#34;
                % building_type
            )

        self.intersections[coords].building = IntersectionBuilding(
            player, building_type, coords
        )

        # Connect the player to a harbor if they can
        for harbor in self.harbors.values():
            if coords in harbor.path_coords and harbor not in player.connected_harbors:
                player.connected_harbors.add(harbor)

    def assert_valid_settlement_coords(
        self, coords: Coords, player: Player, ensure_connected: Optional[bool]
    ) -&gt; None:
        &#34;&#34;&#34;Check whether the coordinates given are a valid place to build a settlement.

        Does not return anything, but raises an error if the coordinates are not valid.

        Args:
            coords: The coordinates to check
            player: The player building the settlement
            ensure_connected: Whether the check if the settlement will be connected by road
        Raises:
            TooCloseToBuildingError: If the building is too close to another building
            PositionAlreadyTakenError: If the position is already taken
            NotConnectedError: If `check_connection` is `True` and the settlement is not connected
        &#34;&#34;&#34;
        # Check that the coords are referencing a intersection
        if coords not in self.intersections:
            raise InvalidCoordsError(&#34;coords must be the coordinates of a intersection&#34;)
        # Check that the intersection is empty
        if self.intersections[coords].building is not None:
            raise CoordsBlockedError(&#34;There is already a building on this intersection&#34;)
        # Check that the surrounding intersections are empty
        connected_intersections: Set[
            Intersection
        ] = self.get_intersection_connected_intersections(self.intersections[coords])
        if (
            len(set(filter(lambda c: c.building is not None, connected_intersections)))
            &gt; 0
        ):
            raise TooCloseToBuildingError(
                &#34;There is a building that is not at least 2 paths away from this position&#34;
            )
        if ensure_connected:
            path_coords = set(
                map(lambda c: frozenset({coords, c.coords}), connected_intersections)
            )
            paths = set(map(lambda e: self.paths[e], path_coords))
            if (
                len(
                    set(
                        filter(
                            lambda path: path.building is not None
                            and path.building.owner is player,
                            paths,
                        )
                    )
                )
                == 0
            ):
                raise NotConnectedError(&#34;The settlement must be connected by road&#34;)

    def assert_valid_city_coords(self, player: Player, coords: Coords):
        &#34;&#34;&#34;Check whether the coordinates given are a valid place to build a city by the player given.

        Args:
            player: The player building the city
            coords: Where to build the city
        &#34;&#34;&#34;
        # Check the coords are a intersection
        if coords not in self.intersections.keys():
            raise InvalidCoordsError(&#34;coords must be the coordinates of a intersection&#34;)
        # Check that a settlement owned by player exists here
        if (
            self.intersections[coords].building is None
            or self.intersections[coords].building.owner is not player
            or self.intersections[coords].building.building_type
            is not BuildingType.SETTLEMENT
        ):
            raise RequiresSettlementError(
                &#34;You must update an existing settlement owned by the player into a city&#34;
            )

    def is_valid_settlement_coords(
        self, player: Player, coords: Coords, ensure_connected: Optional[bool]
    ) -&gt; bool:
        &#34;&#34;&#34;Check whether the given coordinates are a valid place for the player to build a settlement.

        Args:
            player: The player
            coords: The coordinates to check
            ensure_connected: Whether to ensure that the settlement will be connected to the player&#39;s roads
        Returns:
            Whether the coordinates are a valid settlement location for the player
        &#34;&#34;&#34;
        try:
            self.assert_valid_settlement_coords(
                player=player, coords=coords, ensure_connected=ensure_connected
            )
        except:  # noqa: E722
            return False
        return True

    def is_valid_city_coords(self, player: Player, coords: Coords) -&gt; bool:
        &#34;&#34;&#34;Check whether the coordinates given are valid city coordinates.

        Args:
            player: The player
            coords: The coordinates to check
        Returns:
            Whether the coords are a valid place for the player to build a city
        &#34;&#34;&#34;
        try:
            self.assert_valid_city_coords(player=player, coords=coords)
        except:  # noqa: E722
            return False
        return True

    def is_valid_road_coords(
        self,
        player: Player,
        path_coords: Set[Coords],
        ensure_connected: Optional[bool] = True,
    ) -&gt; bool:
        &#34;&#34;&#34;Check whether the path coordinates given are valid road coordinate for the player given.

        Args:
            player: The player
            path_coords: The coordinates of the path
            ensure_connected: Whether to ensure that the road is connected to the player&#39;s existing roads/buildings. Defaults to True
        Returns:
            Whether the player can build a road on this path
        &#34;&#34;&#34;
        try:
            self.assert_valid_road_coords(
                player, path_coords, ensure_connected=ensure_connected
            )
        except:  # noqa: E722
            return False
        return True

    def get_valid_settlement_coords(
        self, player: Player, ensure_connected: Optional[bool] = True
    ) -&gt; Set[Coords]:
        &#34;&#34;&#34;Get all the valid settlement coordinates for the player to build a settlement.

        Args:
            player: The player to check for valid settlement coordinates
            ensure_connected: Whether to ensure the coordinates are connected to the player&#39;s roads
        Returns:
            The coordinates of all the valid settlement intersections
        &#34;&#34;&#34;
        return set(
            [
                i
                for i in self.intersections.keys()
                if self.is_valid_settlement_coords(player, i, ensure_connected)
            ]
        )

    def get_valid_city_coords(self, player: Player) -&gt; Set[Coords]:
        &#34;&#34;&#34;Get all the valid city coordinates for the player to build a city.

        Args:
            player (Player): The player building the city
        Returns
            The coordinates of all the valid city locations
        &#34;&#34;&#34;
        return set(
            [
                i
                for i in self.intersections.keys()
                if self.is_valid_city_coords(player, i)
            ]
        )

    def get_valid_road_coords(
        self,
        player: Player,
        ensure_connected: Optional[bool] = True,
        connected_intersection: Optional[Coords] = None,
    ) -&gt; Set[FrozenSet[Coords]]:
        &#34;&#34;&#34;Get all the valid coordinates for the player to build a road.

        Args:
            player: The player building the road
            ensure_connected:
                Whether to only return the path coordinates that are connected to the player&#39;s existing roads/settlements. Defaults to True
            connected_intersection: The coords of an intersection that the potential road must be attached to. Defaults to None
        Returns:
            The coordinates of all the paths where the player can build a road.
        &#34;&#34;&#34;
        to_return = set()
        for path_coords in self.paths.keys():
            if self.is_valid_road_coords(
                player=player,
                ensure_connected=ensure_connected,
                path_coords=path_coords,
            ):
                if not connected_intersection or connected_intersection in path_coords:
                    to_return.add(path_coords)

        return to_return

    def get_intersection_connected_intersections(
        self, intersection: Intersection
    ) -&gt; Set[Intersection]:
        &#34;&#34;&#34;Get all the intersections connected to the intersection given by an path.

        Args:
            intersection: The intersection to get the connected intersections for

        Returns:
            The intersections that are connected to the intersection given
        &#34;&#34;&#34;
        connected = set()
        for c in Intersection.CONNECTED_CORNER_OFFSETS:
            if c + intersection.coords in self.intersections.keys():
                connected.add(self.intersections[c + intersection.coords])
        return connected

    def get_connected_hex_intersections(self, hex: Hex) -&gt; Set[Intersection]:
        &#34;&#34;&#34;Get all of the intersections that are connected to the hex.

        Args:
            hex: The hex

        Returns:
            All 6 intersections that are around this hex
        &#34;&#34;&#34;
        return set(
            map(
                lambda offset: self.intersections[hex.coords + offset],
                Hex.CONNECTED_CORNER_OFFSETS,
            )
        )

    def get_hexes_connected_to_intersection(
        self, intersection_coords: Coords
    ) -&gt; Set[Coords]:
        &#34;&#34;&#34;Get all the hexes&#39; coordinates that are connected to the intersection with the coordinates provided.

        Args:
            intersection_coords: The coords of an intersection
        Returns:
            The hexes connected to the intersection
        &#34;&#34;&#34;
        return set(
            [
                intersection_coords + c
                for c in Hex.CONNECTED_CORNER_OFFSETS
                if intersection_coords + c in self.hexes
            ]
        )

    def get_yield_for_roll(self, roll: int) -&gt; Dict[Player, RollYield]:
        &#34;&#34;&#34;Calculate the resources given out for a particular roll.

        Args:
            roll: The number rolled
        Returns:
            The RollYield object containing the information for what each player gets, keyed by the player
        &#34;&#34;&#34;
        total_yield: Dict[Player, RollYield] = {}
        for hex in self.hexes.values():
            if hex.token_number == roll and self.robber != hex.coords:
                resource = hex.hex_type.get_resource()
                # Check around the hex for any settlements/cities
                for intersection in self.get_connected_hex_intersections(hex):
                    if intersection.building is not None:
                        owner = intersection.building.owner
                        if owner not in total_yield.keys():
                            total_yield[owner] = RollYield()
                        amount = (
                            2
                            if intersection.building.building_type is BuildingType.CITY
                            else 1
                        )
                        total_yield[owner].add_yield(
                            resource,
                            amount,
                            source=RollYieldSource(
                                resource,
                                amount,
                                intersection.building,
                                hex,
                            ),
                        )
        return total_yield

    def is_valid_hex_coords(self, coords: Coords) -&gt; bool:
        &#34;&#34;&#34;Check whether the coordinates given are valid hex coordinates.

        Args:
            coords: The coordinates
        Returns:
            Whether there is a hex at those coordinates
        &#34;&#34;&#34;
        return len(set(filter(lambda x: x == coords, self.hexes.keys()))) != 0

    def calculate_player_longest_road(self, player: Player) -&gt; int:
        &#34;&#34;&#34;Calculate the length of the longest road segment for the player given.

        Args:
            player: The player to calculate the longest road for
        Returns:
            The length of the ongest road segment
        &#34;&#34;&#34;
        paths = [
            e
            for e in self.paths.values()
            if e.building is not None and e.building.owner is player
        ]
        starting = [(c, [e]) for e in paths for c in e.path_coords]
        if len(starting) == 0:
            return 0

        current_longest = starting[0][1]

        potential = starting
        while len(potential) &gt; 0:
            current = potential.pop(0)
            building = self.intersections[current[0]].building
            if building is not None and building.owner is not player:
                continue
            for path in self.get_paths_for_intersection_coords(current[0]):
                if (
                    path not in current[1]
                    and path.building is not None
                    and path.building.owner is player
                ):
                    other_intersection = path.other_intersection(current[0])
                    potential.append((other_intersection, [path] + current[1]))
                    if len(current[1]) + 1 &gt; len(current_longest):
                        current_longest = [path] + current[1]

        return len(current_longest)

    def get_paths_for_intersection_coords(self, coords: Coords) -&gt; Set[Path]:
        &#34;&#34;&#34;Get all the paths who that connected to the intersection given.

        Args:
            coords: The coordinates of the intersection
        Returns:
            A set of the paths attached to that intersection
        &#34;&#34;&#34;
        return set(filter(lambda e: coords in e.path_coords, self.paths.values()))

    def get_hex_resources_for_intersection(self, coords: Coords) -&gt; Dict[Resource, int]:
        &#34;&#34;&#34;Get the associated resources for the hexes around the intersection at the coords given.

        Args:
            coords: The coordinates of an intersection
        Returns:
            The amounts of resources from the hexes around this intersection
        &#34;&#34;&#34;
        resources = [
            self.hexes[h].hex_type.get_resource()
            for h in self.get_hexes_connected_to_intersection(coords)
        ]
        return {res: resources.count(res) for res in resources if res is not None}

    def get_players_on_hex(self, coords: Coords) -&gt; Set[Player]:
        &#34;&#34;&#34;Get all the players who have a building on the edge of the given hex.

        Args:
            coords: The coords of the hex
        Returns:
            The players with a building on the edge of the hex
        &#34;&#34;&#34;
        return set(
            [
                i.building.owner
                for i in self.get_connected_hex_intersections(self.hexes[coords])
                if i.building is not None
            ]
        )

    def __str__(self):
        from .board_renderer import BoardRenderer

        return BoardRenderer(self).get_board_as_string()

    def __repl__(self):
        return self.__str__()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="katan_ai.katan.board.board.Board"><code class="flex name class">
<span>class <span class="ident">Board</span></span>
<span>(</span><span>hexes: Set[<a title="katan_ai.katan.board.hex.Hex" href="hex.html#katan_ai.katan.board.hex.Hex">Hex</a>], harbors: Set[<a title="katan_ai.katan.board.harbor.Harbor" href="harbor.html#katan_ai.katan.board.harbor.Harbor">Harbor</a>] = set(), robber: <a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>An interface for holding the state of Catan boards.</p>
<p>Uses a triangular grid to hold the tiles, intersections and
paths. The Board constructor will automatically
generate the intersections and paths from a dict of hexes,
assuming all the hexes tile correctly.</p>
<h2 id="args">Args</h2>
<p>hexes:
The hexes on the board, keyed by their coordinates
harbors:
The harbors on the board
robber:
The initial coordinates of the robber. If None, then will automatically place the robber on the first
desert hex it can find, and raise an error if there are non</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt>hexes (Dict[Coord, Hex]):</dt>
<dt>The hexes on this catan board, keyed by their coordinates</dt>
<dt><strong><code>intersections</code></strong></dt>
<dd>(Dict[Coords, Intersection]):
The intersections on the board, keyed by their coordinates</dd>
<dt>paths (Dict[frozenset[Coords], Path]):</dt>
<dt>The paths on the board, keyed by the coordinates of the two intersections they connect</dt>
<dt>harbors (Dict[frozenset[Coords], Harbor]):</dt>
<dt>The harbors on the board, keyed by the coords of the path they are attached to</dt>
<dt><strong><code>robber</code></strong> :&ensp;<code>Set[Coords]</code></dt>
<dd>The location of the robber</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Board:
    &#34;&#34;&#34;An interface for holding the state of Catan boards.

    Uses a triangular grid to hold the tiles, intersections and
    paths. The Board constructor will automatically
    generate the intersections and paths from a dict of hexes,
    assuming all the hexes tile correctly.

    Args:
        hexes:
            The hexes on the board, keyed by their coordinates
        harbors:
            The harbors on the board
        robber:
            The initial coordinates of the robber. If None, then will automatically place the robber on the first
            desert hex it can find, and raise an error if there are non

    Attributes:
        hexes (Dict[Coord, Hex]):
            The hexes on this catan board, keyed by their coordinates
        intersections: (Dict[Coords, Intersection]):
            The intersections on the board, keyed by their coordinates
        paths (Dict[frozenset[Coords], Path]):
            The paths on the board, keyed by the coordinates of the two intersections they connect
        harbors (Dict[frozenset[Coords], Harbor]):
            The harbors on the board, keyed by the coords of the path they are attached to
        robber (Set[Coords]): The location of the robber
    &#34;&#34;&#34;

    def __init__(
        self, hexes: Set[Hex], harbors: Set[Harbor] = set(), robber: Coords = None
    ):
        self.hexes: Dict[Coords, Hex] = dict(zip((h.coords for h in hexes), hexes))
        self.harbors = {frozenset(h.path_coords): h for h in harbors}
        # Position the robber on the desert
        if robber:
            self.robber = robber
        else:
            self.robber = [
                h.coords for h in self.hexes.values() if h.hex_type == HexType.DESERT
            ][0]
        # Gather the points around each hex into a set
        intersection_coords = set(
            map(
                lambda x: x[0] + x[1],
                list(product(*[self.hexes.keys(), Hex.CONNECTED_CORNER_OFFSETS])),
            )
        )
        # Add the intersections to self.intersections
        self.intersections = {}
        for coords in intersection_coords:
            self.intersections[coords] = Intersection(coords)
        # Now add all the edges in between the intersections we just added
        self.paths = {}
        for c in self.intersections:
            for offset in Intersection.CONNECTED_CORNER_OFFSETS:
                coord = c + offset
                if coord in self.intersections:
                    self.paths[frozenset([c, c + offset])] = Path(set([c, c + offset]))

    def add_path_building(
        self,
        player: Player,
        building_type: BuildingType,
        path_coords: Set[Coords],
        ensure_connected: Optional[bool] = True,
    ):
        &#34;&#34;&#34;Add an path building to the board.

        Do not check if the player has enough resources, or any other checks other than the building&#39;s location being valid.

        Args:
            player: The player adding the building
            building_type: The building_type of the building being added
            path_coords: The coordinates the path to build the building on (i.e. the coordinates of the two intersections the path connects)
            ensure_connected: Whether to ensure that the path building is connected to another building. Defaults to True
        Raises:
            ValueError: If the path_coords are not valid
            CoordsBlockedError: If there is already a building on the path
            NotConnectedError: If check_connection is true and the building is not connected to anything
        &#34;&#34;&#34;
        for c in path_coords:
            if c not in self.intersections.keys():
                raise ValueError(
                    &#34;Invalid path: Paths must connect two intersections on the board. %s is not a intersection&#34;
                    % c
                )

        if frozenset(path_coords) not in self.paths.keys():
            raise ValueError(&#34;Invalid path: Path does not exist&#34;)

        if building_type is BuildingType.ROAD:
            self.assert_valid_road_coords(player, path_coords, ensure_connected)

        # Add the building
        self.paths[frozenset(path_coords)].building = PathBuilding(
            player, path_coords=path_coords, building_type=building_type
        )

    def assert_valid_road_coords(
        self,
        player: Player,
        path_coords: Set[Coords],
        ensure_connected: Optional[bool] = True,
    ):
        &#34;&#34;&#34;Assert that a given edge is a valid place for the player to build a road.

        Args:
            player: The player
            path_coords: The coordinates of the two intersections connected by the path
            ensure_connected: Whether to assert that the path is connected to the player&#39;s existing roads or settlements
        &#34;&#34;&#34;
        path: Path = self.paths[frozenset(path_coords)]
        if path.building is not None:
            raise CoordsBlockedError(&#34;There is already a building on this path&#34;)

        if ensure_connected:
            # Check if it&#39;s connected to a intersection building
            valid_buildings = set(
                filter(
                    lambda b: b is not None and b.owner is player,
                    map(lambda c: self.intersections[c].building, path_coords),
                )
            )
            if len(valid_buildings) == 0:
                # Check if it&#39;s connected to another path building
                paths_connected = set()
                for coords in path_coords:
                    for c in self.get_intersection_connected_intersections(
                        self.intersections[coords]
                    ):
                        connected_path = self.paths[frozenset({coords, c.coords})]
                        # Check if there is an path building (i.e. a road) to be connected to here
                        if (
                            connected_path.building is not None
                            and connected_path.building.owner is player
                        ):
                            # Checks that we aren&#39;t going through an enemy building to be connected
                            building = self.intersections[coords].building
                            if building is None or building.owner is player:
                                paths_connected.add(path)

                if len(paths_connected) == 0:
                    raise NotConnectedError(
                        &#34;Road is not connected to any other building&#34;
                    )

    def add_intersection_building(
        self,
        player: Player,
        coords: Coords,
        building_type: BuildingType,
        ensure_connected: Optional[bool] = True,
    ):
        &#34;&#34;&#34;Add an intersection building to the board.

        Args:
            player: The player who owns the settlement
            coords: The coords to put the building
            ensure_connected: Whether to ensure that the building is connected to the player&#39;s roads. Defaults to True
        Raises:
            InvalidCoordsError: If coords is not a valid intersection
            TooCloseToBuildingError: If the building is too close to another building
            PositionAlreadyTakenError: If the position is already taken
        &#34;&#34;&#34;
        if building_type == BuildingType.SETTLEMENT:
            self.assert_valid_settlement_coords(coords, player, ensure_connected)
        elif building_type == BuildingType.CITY:
            self.assert_valid_city_coords(player=player, coords=coords)
        else:
            raise ValueError(
                &#34;Invalid building type passed to Board.add_intersection_building, received %s&#34;
                % building_type
            )

        self.intersections[coords].building = IntersectionBuilding(
            player, building_type, coords
        )

        # Connect the player to a harbor if they can
        for harbor in self.harbors.values():
            if coords in harbor.path_coords and harbor not in player.connected_harbors:
                player.connected_harbors.add(harbor)

    def assert_valid_settlement_coords(
        self, coords: Coords, player: Player, ensure_connected: Optional[bool]
    ) -&gt; None:
        &#34;&#34;&#34;Check whether the coordinates given are a valid place to build a settlement.

        Does not return anything, but raises an error if the coordinates are not valid.

        Args:
            coords: The coordinates to check
            player: The player building the settlement
            ensure_connected: Whether the check if the settlement will be connected by road
        Raises:
            TooCloseToBuildingError: If the building is too close to another building
            PositionAlreadyTakenError: If the position is already taken
            NotConnectedError: If `check_connection` is `True` and the settlement is not connected
        &#34;&#34;&#34;
        # Check that the coords are referencing a intersection
        if coords not in self.intersections:
            raise InvalidCoordsError(&#34;coords must be the coordinates of a intersection&#34;)
        # Check that the intersection is empty
        if self.intersections[coords].building is not None:
            raise CoordsBlockedError(&#34;There is already a building on this intersection&#34;)
        # Check that the surrounding intersections are empty
        connected_intersections: Set[
            Intersection
        ] = self.get_intersection_connected_intersections(self.intersections[coords])
        if (
            len(set(filter(lambda c: c.building is not None, connected_intersections)))
            &gt; 0
        ):
            raise TooCloseToBuildingError(
                &#34;There is a building that is not at least 2 paths away from this position&#34;
            )
        if ensure_connected:
            path_coords = set(
                map(lambda c: frozenset({coords, c.coords}), connected_intersections)
            )
            paths = set(map(lambda e: self.paths[e], path_coords))
            if (
                len(
                    set(
                        filter(
                            lambda path: path.building is not None
                            and path.building.owner is player,
                            paths,
                        )
                    )
                )
                == 0
            ):
                raise NotConnectedError(&#34;The settlement must be connected by road&#34;)

    def assert_valid_city_coords(self, player: Player, coords: Coords):
        &#34;&#34;&#34;Check whether the coordinates given are a valid place to build a city by the player given.

        Args:
            player: The player building the city
            coords: Where to build the city
        &#34;&#34;&#34;
        # Check the coords are a intersection
        if coords not in self.intersections.keys():
            raise InvalidCoordsError(&#34;coords must be the coordinates of a intersection&#34;)
        # Check that a settlement owned by player exists here
        if (
            self.intersections[coords].building is None
            or self.intersections[coords].building.owner is not player
            or self.intersections[coords].building.building_type
            is not BuildingType.SETTLEMENT
        ):
            raise RequiresSettlementError(
                &#34;You must update an existing settlement owned by the player into a city&#34;
            )

    def is_valid_settlement_coords(
        self, player: Player, coords: Coords, ensure_connected: Optional[bool]
    ) -&gt; bool:
        &#34;&#34;&#34;Check whether the given coordinates are a valid place for the player to build a settlement.

        Args:
            player: The player
            coords: The coordinates to check
            ensure_connected: Whether to ensure that the settlement will be connected to the player&#39;s roads
        Returns:
            Whether the coordinates are a valid settlement location for the player
        &#34;&#34;&#34;
        try:
            self.assert_valid_settlement_coords(
                player=player, coords=coords, ensure_connected=ensure_connected
            )
        except:  # noqa: E722
            return False
        return True

    def is_valid_city_coords(self, player: Player, coords: Coords) -&gt; bool:
        &#34;&#34;&#34;Check whether the coordinates given are valid city coordinates.

        Args:
            player: The player
            coords: The coordinates to check
        Returns:
            Whether the coords are a valid place for the player to build a city
        &#34;&#34;&#34;
        try:
            self.assert_valid_city_coords(player=player, coords=coords)
        except:  # noqa: E722
            return False
        return True

    def is_valid_road_coords(
        self,
        player: Player,
        path_coords: Set[Coords],
        ensure_connected: Optional[bool] = True,
    ) -&gt; bool:
        &#34;&#34;&#34;Check whether the path coordinates given are valid road coordinate for the player given.

        Args:
            player: The player
            path_coords: The coordinates of the path
            ensure_connected: Whether to ensure that the road is connected to the player&#39;s existing roads/buildings. Defaults to True
        Returns:
            Whether the player can build a road on this path
        &#34;&#34;&#34;
        try:
            self.assert_valid_road_coords(
                player, path_coords, ensure_connected=ensure_connected
            )
        except:  # noqa: E722
            return False
        return True

    def get_valid_settlement_coords(
        self, player: Player, ensure_connected: Optional[bool] = True
    ) -&gt; Set[Coords]:
        &#34;&#34;&#34;Get all the valid settlement coordinates for the player to build a settlement.

        Args:
            player: The player to check for valid settlement coordinates
            ensure_connected: Whether to ensure the coordinates are connected to the player&#39;s roads
        Returns:
            The coordinates of all the valid settlement intersections
        &#34;&#34;&#34;
        return set(
            [
                i
                for i in self.intersections.keys()
                if self.is_valid_settlement_coords(player, i, ensure_connected)
            ]
        )

    def get_valid_city_coords(self, player: Player) -&gt; Set[Coords]:
        &#34;&#34;&#34;Get all the valid city coordinates for the player to build a city.

        Args:
            player (Player): The player building the city
        Returns
            The coordinates of all the valid city locations
        &#34;&#34;&#34;
        return set(
            [
                i
                for i in self.intersections.keys()
                if self.is_valid_city_coords(player, i)
            ]
        )

    def get_valid_road_coords(
        self,
        player: Player,
        ensure_connected: Optional[bool] = True,
        connected_intersection: Optional[Coords] = None,
    ) -&gt; Set[FrozenSet[Coords]]:
        &#34;&#34;&#34;Get all the valid coordinates for the player to build a road.

        Args:
            player: The player building the road
            ensure_connected:
                Whether to only return the path coordinates that are connected to the player&#39;s existing roads/settlements. Defaults to True
            connected_intersection: The coords of an intersection that the potential road must be attached to. Defaults to None
        Returns:
            The coordinates of all the paths where the player can build a road.
        &#34;&#34;&#34;
        to_return = set()
        for path_coords in self.paths.keys():
            if self.is_valid_road_coords(
                player=player,
                ensure_connected=ensure_connected,
                path_coords=path_coords,
            ):
                if not connected_intersection or connected_intersection in path_coords:
                    to_return.add(path_coords)

        return to_return

    def get_intersection_connected_intersections(
        self, intersection: Intersection
    ) -&gt; Set[Intersection]:
        &#34;&#34;&#34;Get all the intersections connected to the intersection given by an path.

        Args:
            intersection: The intersection to get the connected intersections for

        Returns:
            The intersections that are connected to the intersection given
        &#34;&#34;&#34;
        connected = set()
        for c in Intersection.CONNECTED_CORNER_OFFSETS:
            if c + intersection.coords in self.intersections.keys():
                connected.add(self.intersections[c + intersection.coords])
        return connected

    def get_connected_hex_intersections(self, hex: Hex) -&gt; Set[Intersection]:
        &#34;&#34;&#34;Get all of the intersections that are connected to the hex.

        Args:
            hex: The hex

        Returns:
            All 6 intersections that are around this hex
        &#34;&#34;&#34;
        return set(
            map(
                lambda offset: self.intersections[hex.coords + offset],
                Hex.CONNECTED_CORNER_OFFSETS,
            )
        )

    def get_hexes_connected_to_intersection(
        self, intersection_coords: Coords
    ) -&gt; Set[Coords]:
        &#34;&#34;&#34;Get all the hexes&#39; coordinates that are connected to the intersection with the coordinates provided.

        Args:
            intersection_coords: The coords of an intersection
        Returns:
            The hexes connected to the intersection
        &#34;&#34;&#34;
        return set(
            [
                intersection_coords + c
                for c in Hex.CONNECTED_CORNER_OFFSETS
                if intersection_coords + c in self.hexes
            ]
        )

    def get_yield_for_roll(self, roll: int) -&gt; Dict[Player, RollYield]:
        &#34;&#34;&#34;Calculate the resources given out for a particular roll.

        Args:
            roll: The number rolled
        Returns:
            The RollYield object containing the information for what each player gets, keyed by the player
        &#34;&#34;&#34;
        total_yield: Dict[Player, RollYield] = {}
        for hex in self.hexes.values():
            if hex.token_number == roll and self.robber != hex.coords:
                resource = hex.hex_type.get_resource()
                # Check around the hex for any settlements/cities
                for intersection in self.get_connected_hex_intersections(hex):
                    if intersection.building is not None:
                        owner = intersection.building.owner
                        if owner not in total_yield.keys():
                            total_yield[owner] = RollYield()
                        amount = (
                            2
                            if intersection.building.building_type is BuildingType.CITY
                            else 1
                        )
                        total_yield[owner].add_yield(
                            resource,
                            amount,
                            source=RollYieldSource(
                                resource,
                                amount,
                                intersection.building,
                                hex,
                            ),
                        )
        return total_yield

    def is_valid_hex_coords(self, coords: Coords) -&gt; bool:
        &#34;&#34;&#34;Check whether the coordinates given are valid hex coordinates.

        Args:
            coords: The coordinates
        Returns:
            Whether there is a hex at those coordinates
        &#34;&#34;&#34;
        return len(set(filter(lambda x: x == coords, self.hexes.keys()))) != 0

    def calculate_player_longest_road(self, player: Player) -&gt; int:
        &#34;&#34;&#34;Calculate the length of the longest road segment for the player given.

        Args:
            player: The player to calculate the longest road for
        Returns:
            The length of the ongest road segment
        &#34;&#34;&#34;
        paths = [
            e
            for e in self.paths.values()
            if e.building is not None and e.building.owner is player
        ]
        starting = [(c, [e]) for e in paths for c in e.path_coords]
        if len(starting) == 0:
            return 0

        current_longest = starting[0][1]

        potential = starting
        while len(potential) &gt; 0:
            current = potential.pop(0)
            building = self.intersections[current[0]].building
            if building is not None and building.owner is not player:
                continue
            for path in self.get_paths_for_intersection_coords(current[0]):
                if (
                    path not in current[1]
                    and path.building is not None
                    and path.building.owner is player
                ):
                    other_intersection = path.other_intersection(current[0])
                    potential.append((other_intersection, [path] + current[1]))
                    if len(current[1]) + 1 &gt; len(current_longest):
                        current_longest = [path] + current[1]

        return len(current_longest)

    def get_paths_for_intersection_coords(self, coords: Coords) -&gt; Set[Path]:
        &#34;&#34;&#34;Get all the paths who that connected to the intersection given.

        Args:
            coords: The coordinates of the intersection
        Returns:
            A set of the paths attached to that intersection
        &#34;&#34;&#34;
        return set(filter(lambda e: coords in e.path_coords, self.paths.values()))

    def get_hex_resources_for_intersection(self, coords: Coords) -&gt; Dict[Resource, int]:
        &#34;&#34;&#34;Get the associated resources for the hexes around the intersection at the coords given.

        Args:
            coords: The coordinates of an intersection
        Returns:
            The amounts of resources from the hexes around this intersection
        &#34;&#34;&#34;
        resources = [
            self.hexes[h].hex_type.get_resource()
            for h in self.get_hexes_connected_to_intersection(coords)
        ]
        return {res: resources.count(res) for res in resources if res is not None}

    def get_players_on_hex(self, coords: Coords) -&gt; Set[Player]:
        &#34;&#34;&#34;Get all the players who have a building on the edge of the given hex.

        Args:
            coords: The coords of the hex
        Returns:
            The players with a building on the edge of the hex
        &#34;&#34;&#34;
        return set(
            [
                i.building.owner
                for i in self.get_connected_hex_intersections(self.hexes[coords])
                if i.building is not None
            ]
        )

    def __str__(self):
        from .board_renderer import BoardRenderer

        return BoardRenderer(self).get_board_as_string()

    def __repl__(self):
        return self.__str__()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="katan_ai.katan.board.beginner_board.BeginnerBoard" href="beginner_board.html#katan_ai.katan.board.beginner_board.BeginnerBoard">BeginnerBoard</a></li>
<li><a title="katan_ai.katan.board.random_board.RandomBoard" href="random_board.html#katan_ai.katan.board.random_board.RandomBoard">RandomBoard</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="katan_ai.katan.board.board.Board.add_intersection_building"><code class="name flex">
<span>def <span class="ident">add_intersection_building</span></span>(<span>self, player: <a title="katan_ai.katan.player.Player" href="../player.html#katan_ai.katan.player.Player">Player</a>, coords: <a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>, building_type: <a title="katan_ai.katan.board.building_type.BuildingType" href="building_type.html#katan_ai.katan.board.building_type.BuildingType">BuildingType</a>, ensure_connected: Optional[bool] = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an intersection building to the board.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player who owns the settlement</dd>
<dt><strong><code>coords</code></strong></dt>
<dd>The coords to put the building</dd>
<dt><strong><code>ensure_connected</code></strong></dt>
<dd>Whether to ensure that the building is connected to the player's roads. Defaults to True</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>InvalidCoordsError</code></dt>
<dd>If coords is not a valid intersection</dd>
<dt><code>TooCloseToBuildingError</code></dt>
<dd>If the building is too close to another building</dd>
<dt><code>PositionAlreadyTakenError</code></dt>
<dd>If the position is already taken</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_intersection_building(
    self,
    player: Player,
    coords: Coords,
    building_type: BuildingType,
    ensure_connected: Optional[bool] = True,
):
    &#34;&#34;&#34;Add an intersection building to the board.

    Args:
        player: The player who owns the settlement
        coords: The coords to put the building
        ensure_connected: Whether to ensure that the building is connected to the player&#39;s roads. Defaults to True
    Raises:
        InvalidCoordsError: If coords is not a valid intersection
        TooCloseToBuildingError: If the building is too close to another building
        PositionAlreadyTakenError: If the position is already taken
    &#34;&#34;&#34;
    if building_type == BuildingType.SETTLEMENT:
        self.assert_valid_settlement_coords(coords, player, ensure_connected)
    elif building_type == BuildingType.CITY:
        self.assert_valid_city_coords(player=player, coords=coords)
    else:
        raise ValueError(
            &#34;Invalid building type passed to Board.add_intersection_building, received %s&#34;
            % building_type
        )

    self.intersections[coords].building = IntersectionBuilding(
        player, building_type, coords
    )

    # Connect the player to a harbor if they can
    for harbor in self.harbors.values():
        if coords in harbor.path_coords and harbor not in player.connected_harbors:
            player.connected_harbors.add(harbor)</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.add_path_building"><code class="name flex">
<span>def <span class="ident">add_path_building</span></span>(<span>self, player: <a title="katan_ai.katan.player.Player" href="../player.html#katan_ai.katan.player.Player">Player</a>, building_type: <a title="katan_ai.katan.board.building_type.BuildingType" href="building_type.html#katan_ai.katan.board.building_type.BuildingType">BuildingType</a>, path_coords: Set[<a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>], ensure_connected: Optional[bool] = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an path building to the board.</p>
<p>Do not check if the player has enough resources, or any other checks other than the building's location being valid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player adding the building</dd>
<dt><strong><code>building_type</code></strong></dt>
<dd>The building_type of the building being added</dd>
<dt><strong><code>path_coords</code></strong></dt>
<dd>The coordinates the path to build the building on (i.e. the coordinates of the two intersections the path connects)</dd>
<dt><strong><code>ensure_connected</code></strong></dt>
<dd>Whether to ensure that the path building is connected to another building. Defaults to True</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the path_coords are not valid</dd>
<dt><code>CoordsBlockedError</code></dt>
<dd>If there is already a building on the path</dd>
<dt><code>NotConnectedError</code></dt>
<dd>If check_connection is true and the building is not connected to anything</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_path_building(
    self,
    player: Player,
    building_type: BuildingType,
    path_coords: Set[Coords],
    ensure_connected: Optional[bool] = True,
):
    &#34;&#34;&#34;Add an path building to the board.

    Do not check if the player has enough resources, or any other checks other than the building&#39;s location being valid.

    Args:
        player: The player adding the building
        building_type: The building_type of the building being added
        path_coords: The coordinates the path to build the building on (i.e. the coordinates of the two intersections the path connects)
        ensure_connected: Whether to ensure that the path building is connected to another building. Defaults to True
    Raises:
        ValueError: If the path_coords are not valid
        CoordsBlockedError: If there is already a building on the path
        NotConnectedError: If check_connection is true and the building is not connected to anything
    &#34;&#34;&#34;
    for c in path_coords:
        if c not in self.intersections.keys():
            raise ValueError(
                &#34;Invalid path: Paths must connect two intersections on the board. %s is not a intersection&#34;
                % c
            )

    if frozenset(path_coords) not in self.paths.keys():
        raise ValueError(&#34;Invalid path: Path does not exist&#34;)

    if building_type is BuildingType.ROAD:
        self.assert_valid_road_coords(player, path_coords, ensure_connected)

    # Add the building
    self.paths[frozenset(path_coords)].building = PathBuilding(
        player, path_coords=path_coords, building_type=building_type
    )</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.assert_valid_city_coords"><code class="name flex">
<span>def <span class="ident">assert_valid_city_coords</span></span>(<span>self, player: <a title="katan_ai.katan.player.Player" href="../player.html#katan_ai.katan.player.Player">Player</a>, coords: <a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether the coordinates given are a valid place to build a city by the player given.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player building the city</dd>
<dt><strong><code>coords</code></strong></dt>
<dd>Where to build the city</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_valid_city_coords(self, player: Player, coords: Coords):
    &#34;&#34;&#34;Check whether the coordinates given are a valid place to build a city by the player given.

    Args:
        player: The player building the city
        coords: Where to build the city
    &#34;&#34;&#34;
    # Check the coords are a intersection
    if coords not in self.intersections.keys():
        raise InvalidCoordsError(&#34;coords must be the coordinates of a intersection&#34;)
    # Check that a settlement owned by player exists here
    if (
        self.intersections[coords].building is None
        or self.intersections[coords].building.owner is not player
        or self.intersections[coords].building.building_type
        is not BuildingType.SETTLEMENT
    ):
        raise RequiresSettlementError(
            &#34;You must update an existing settlement owned by the player into a city&#34;
        )</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.assert_valid_road_coords"><code class="name flex">
<span>def <span class="ident">assert_valid_road_coords</span></span>(<span>self, player: <a title="katan_ai.katan.player.Player" href="../player.html#katan_ai.katan.player.Player">Player</a>, path_coords: Set[<a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>], ensure_connected: Optional[bool] = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Assert that a given edge is a valid place for the player to build a road.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player</dd>
<dt><strong><code>path_coords</code></strong></dt>
<dd>The coordinates of the two intersections connected by the path</dd>
<dt><strong><code>ensure_connected</code></strong></dt>
<dd>Whether to assert that the path is connected to the player's existing roads or settlements</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_valid_road_coords(
    self,
    player: Player,
    path_coords: Set[Coords],
    ensure_connected: Optional[bool] = True,
):
    &#34;&#34;&#34;Assert that a given edge is a valid place for the player to build a road.

    Args:
        player: The player
        path_coords: The coordinates of the two intersections connected by the path
        ensure_connected: Whether to assert that the path is connected to the player&#39;s existing roads or settlements
    &#34;&#34;&#34;
    path: Path = self.paths[frozenset(path_coords)]
    if path.building is not None:
        raise CoordsBlockedError(&#34;There is already a building on this path&#34;)

    if ensure_connected:
        # Check if it&#39;s connected to a intersection building
        valid_buildings = set(
            filter(
                lambda b: b is not None and b.owner is player,
                map(lambda c: self.intersections[c].building, path_coords),
            )
        )
        if len(valid_buildings) == 0:
            # Check if it&#39;s connected to another path building
            paths_connected = set()
            for coords in path_coords:
                for c in self.get_intersection_connected_intersections(
                    self.intersections[coords]
                ):
                    connected_path = self.paths[frozenset({coords, c.coords})]
                    # Check if there is an path building (i.e. a road) to be connected to here
                    if (
                        connected_path.building is not None
                        and connected_path.building.owner is player
                    ):
                        # Checks that we aren&#39;t going through an enemy building to be connected
                        building = self.intersections[coords].building
                        if building is None or building.owner is player:
                            paths_connected.add(path)

            if len(paths_connected) == 0:
                raise NotConnectedError(
                    &#34;Road is not connected to any other building&#34;
                )</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.assert_valid_settlement_coords"><code class="name flex">
<span>def <span class="ident">assert_valid_settlement_coords</span></span>(<span>self, coords: <a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>, player: <a title="katan_ai.katan.player.Player" href="../player.html#katan_ai.katan.player.Player">Player</a>, ensure_connected: Optional[bool]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether the coordinates given are a valid place to build a settlement.</p>
<p>Does not return anything, but raises an error if the coordinates are not valid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coords</code></strong></dt>
<dd>The coordinates to check</dd>
<dt><strong><code>player</code></strong></dt>
<dd>The player building the settlement</dd>
<dt><strong><code>ensure_connected</code></strong></dt>
<dd>Whether the check if the settlement will be connected by road</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TooCloseToBuildingError</code></dt>
<dd>If the building is too close to another building</dd>
<dt><code>PositionAlreadyTakenError</code></dt>
<dd>If the position is already taken</dd>
<dt><code>NotConnectedError</code></dt>
<dd>If <code>check_connection</code> is <code>True</code> and the settlement is not connected</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_valid_settlement_coords(
    self, coords: Coords, player: Player, ensure_connected: Optional[bool]
) -&gt; None:
    &#34;&#34;&#34;Check whether the coordinates given are a valid place to build a settlement.

    Does not return anything, but raises an error if the coordinates are not valid.

    Args:
        coords: The coordinates to check
        player: The player building the settlement
        ensure_connected: Whether the check if the settlement will be connected by road
    Raises:
        TooCloseToBuildingError: If the building is too close to another building
        PositionAlreadyTakenError: If the position is already taken
        NotConnectedError: If `check_connection` is `True` and the settlement is not connected
    &#34;&#34;&#34;
    # Check that the coords are referencing a intersection
    if coords not in self.intersections:
        raise InvalidCoordsError(&#34;coords must be the coordinates of a intersection&#34;)
    # Check that the intersection is empty
    if self.intersections[coords].building is not None:
        raise CoordsBlockedError(&#34;There is already a building on this intersection&#34;)
    # Check that the surrounding intersections are empty
    connected_intersections: Set[
        Intersection
    ] = self.get_intersection_connected_intersections(self.intersections[coords])
    if (
        len(set(filter(lambda c: c.building is not None, connected_intersections)))
        &gt; 0
    ):
        raise TooCloseToBuildingError(
            &#34;There is a building that is not at least 2 paths away from this position&#34;
        )
    if ensure_connected:
        path_coords = set(
            map(lambda c: frozenset({coords, c.coords}), connected_intersections)
        )
        paths = set(map(lambda e: self.paths[e], path_coords))
        if (
            len(
                set(
                    filter(
                        lambda path: path.building is not None
                        and path.building.owner is player,
                        paths,
                    )
                )
            )
            == 0
        ):
            raise NotConnectedError(&#34;The settlement must be connected by road&#34;)</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.calculate_player_longest_road"><code class="name flex">
<span>def <span class="ident">calculate_player_longest_road</span></span>(<span>self, player: <a title="katan_ai.katan.player.Player" href="../player.html#katan_ai.katan.player.Player">Player</a>) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the length of the longest road segment for the player given.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player to calculate the longest road for</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The length of the ongest road segment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_player_longest_road(self, player: Player) -&gt; int:
    &#34;&#34;&#34;Calculate the length of the longest road segment for the player given.

    Args:
        player: The player to calculate the longest road for
    Returns:
        The length of the ongest road segment
    &#34;&#34;&#34;
    paths = [
        e
        for e in self.paths.values()
        if e.building is not None and e.building.owner is player
    ]
    starting = [(c, [e]) for e in paths for c in e.path_coords]
    if len(starting) == 0:
        return 0

    current_longest = starting[0][1]

    potential = starting
    while len(potential) &gt; 0:
        current = potential.pop(0)
        building = self.intersections[current[0]].building
        if building is not None and building.owner is not player:
            continue
        for path in self.get_paths_for_intersection_coords(current[0]):
            if (
                path not in current[1]
                and path.building is not None
                and path.building.owner is player
            ):
                other_intersection = path.other_intersection(current[0])
                potential.append((other_intersection, [path] + current[1]))
                if len(current[1]) + 1 &gt; len(current_longest):
                    current_longest = [path] + current[1]

    return len(current_longest)</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.get_connected_hex_intersections"><code class="name flex">
<span>def <span class="ident">get_connected_hex_intersections</span></span>(<span>self, hex: <a title="katan_ai.katan.board.hex.Hex" href="hex.html#katan_ai.katan.board.hex.Hex">Hex</a>) ‑> Set[<a title="katan_ai.katan.board.intersection.Intersection" href="intersection.html#katan_ai.katan.board.intersection.Intersection">Intersection</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all of the intersections that are connected to the hex.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hex</code></strong></dt>
<dd>The hex</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>All 6 intersections that are around this hex</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_connected_hex_intersections(self, hex: Hex) -&gt; Set[Intersection]:
    &#34;&#34;&#34;Get all of the intersections that are connected to the hex.

    Args:
        hex: The hex

    Returns:
        All 6 intersections that are around this hex
    &#34;&#34;&#34;
    return set(
        map(
            lambda offset: self.intersections[hex.coords + offset],
            Hex.CONNECTED_CORNER_OFFSETS,
        )
    )</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.get_hex_resources_for_intersection"><code class="name flex">
<span>def <span class="ident">get_hex_resources_for_intersection</span></span>(<span>self, coords: <a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>) ‑> Dict[<a title="katan_ai.katan.resource.Resource" href="../resource.html#katan_ai.katan.resource.Resource">Resource</a>, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the associated resources for the hexes around the intersection at the coords given.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coords</code></strong></dt>
<dd>The coordinates of an intersection</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The amounts of resources from the hexes around this intersection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hex_resources_for_intersection(self, coords: Coords) -&gt; Dict[Resource, int]:
    &#34;&#34;&#34;Get the associated resources for the hexes around the intersection at the coords given.

    Args:
        coords: The coordinates of an intersection
    Returns:
        The amounts of resources from the hexes around this intersection
    &#34;&#34;&#34;
    resources = [
        self.hexes[h].hex_type.get_resource()
        for h in self.get_hexes_connected_to_intersection(coords)
    ]
    return {res: resources.count(res) for res in resources if res is not None}</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.get_hexes_connected_to_intersection"><code class="name flex">
<span>def <span class="ident">get_hexes_connected_to_intersection</span></span>(<span>self, intersection_coords: <a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>) ‑> Set[<a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all the hexes' coordinates that are connected to the intersection with the coordinates provided.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>intersection_coords</code></strong></dt>
<dd>The coords of an intersection</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The hexes connected to the intersection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hexes_connected_to_intersection(
    self, intersection_coords: Coords
) -&gt; Set[Coords]:
    &#34;&#34;&#34;Get all the hexes&#39; coordinates that are connected to the intersection with the coordinates provided.

    Args:
        intersection_coords: The coords of an intersection
    Returns:
        The hexes connected to the intersection
    &#34;&#34;&#34;
    return set(
        [
            intersection_coords + c
            for c in Hex.CONNECTED_CORNER_OFFSETS
            if intersection_coords + c in self.hexes
        ]
    )</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.get_intersection_connected_intersections"><code class="name flex">
<span>def <span class="ident">get_intersection_connected_intersections</span></span>(<span>self, intersection: <a title="katan_ai.katan.board.intersection.Intersection" href="intersection.html#katan_ai.katan.board.intersection.Intersection">Intersection</a>) ‑> Set[<a title="katan_ai.katan.board.intersection.Intersection" href="intersection.html#katan_ai.katan.board.intersection.Intersection">Intersection</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all the intersections connected to the intersection given by an path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>intersection</code></strong></dt>
<dd>The intersection to get the connected intersections for</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The intersections that are connected to the intersection given</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_intersection_connected_intersections(
    self, intersection: Intersection
) -&gt; Set[Intersection]:
    &#34;&#34;&#34;Get all the intersections connected to the intersection given by an path.

    Args:
        intersection: The intersection to get the connected intersections for

    Returns:
        The intersections that are connected to the intersection given
    &#34;&#34;&#34;
    connected = set()
    for c in Intersection.CONNECTED_CORNER_OFFSETS:
        if c + intersection.coords in self.intersections.keys():
            connected.add(self.intersections[c + intersection.coords])
    return connected</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.get_paths_for_intersection_coords"><code class="name flex">
<span>def <span class="ident">get_paths_for_intersection_coords</span></span>(<span>self, coords: <a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>) ‑> Set[<a title="katan_ai.katan.board.path.Path" href="path.html#katan_ai.katan.board.path.Path">Path</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all the paths who that connected to the intersection given.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coords</code></strong></dt>
<dd>The coordinates of the intersection</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A set of the paths attached to that intersection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_paths_for_intersection_coords(self, coords: Coords) -&gt; Set[Path]:
    &#34;&#34;&#34;Get all the paths who that connected to the intersection given.

    Args:
        coords: The coordinates of the intersection
    Returns:
        A set of the paths attached to that intersection
    &#34;&#34;&#34;
    return set(filter(lambda e: coords in e.path_coords, self.paths.values()))</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.get_players_on_hex"><code class="name flex">
<span>def <span class="ident">get_players_on_hex</span></span>(<span>self, coords: <a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>) ‑> Set[<a title="katan_ai.katan.player.Player" href="../player.html#katan_ai.katan.player.Player">Player</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all the players who have a building on the edge of the given hex.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coords</code></strong></dt>
<dd>The coords of the hex</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The players with a building on the edge of the hex</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_players_on_hex(self, coords: Coords) -&gt; Set[Player]:
    &#34;&#34;&#34;Get all the players who have a building on the edge of the given hex.

    Args:
        coords: The coords of the hex
    Returns:
        The players with a building on the edge of the hex
    &#34;&#34;&#34;
    return set(
        [
            i.building.owner
            for i in self.get_connected_hex_intersections(self.hexes[coords])
            if i.building is not None
        ]
    )</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.get_valid_city_coords"><code class="name flex">
<span>def <span class="ident">get_valid_city_coords</span></span>(<span>self, player: <a title="katan_ai.katan.player.Player" href="../player.html#katan_ai.katan.player.Player">Player</a>) ‑> Set[<a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all the valid city coordinates for the player to build a city.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong> :&ensp;<code>Player</code></dt>
<dd>The player building the city</dd>
</dl>
<p>Returns
The coordinates of all the valid city locations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_city_coords(self, player: Player) -&gt; Set[Coords]:
    &#34;&#34;&#34;Get all the valid city coordinates for the player to build a city.

    Args:
        player (Player): The player building the city
    Returns
        The coordinates of all the valid city locations
    &#34;&#34;&#34;
    return set(
        [
            i
            for i in self.intersections.keys()
            if self.is_valid_city_coords(player, i)
        ]
    )</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.get_valid_road_coords"><code class="name flex">
<span>def <span class="ident">get_valid_road_coords</span></span>(<span>self, player: <a title="katan_ai.katan.player.Player" href="../player.html#katan_ai.katan.player.Player">Player</a>, ensure_connected: Optional[bool] = True, connected_intersection: Optional[<a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>] = None) ‑> Set[FrozenSet[<a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all the valid coordinates for the player to build a road.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player building the road</dd>
<dt>ensure_connected:</dt>
<dt>Whether to only return the path coordinates that are connected to the player's existing roads/settlements. Defaults to True</dt>
<dt><strong><code>connected_intersection</code></strong></dt>
<dd>The coords of an intersection that the potential road must be attached to. Defaults to None</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The coordinates of all the paths where the player can build a road.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_road_coords(
    self,
    player: Player,
    ensure_connected: Optional[bool] = True,
    connected_intersection: Optional[Coords] = None,
) -&gt; Set[FrozenSet[Coords]]:
    &#34;&#34;&#34;Get all the valid coordinates for the player to build a road.

    Args:
        player: The player building the road
        ensure_connected:
            Whether to only return the path coordinates that are connected to the player&#39;s existing roads/settlements. Defaults to True
        connected_intersection: The coords of an intersection that the potential road must be attached to. Defaults to None
    Returns:
        The coordinates of all the paths where the player can build a road.
    &#34;&#34;&#34;
    to_return = set()
    for path_coords in self.paths.keys():
        if self.is_valid_road_coords(
            player=player,
            ensure_connected=ensure_connected,
            path_coords=path_coords,
        ):
            if not connected_intersection or connected_intersection in path_coords:
                to_return.add(path_coords)

    return to_return</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.get_valid_settlement_coords"><code class="name flex">
<span>def <span class="ident">get_valid_settlement_coords</span></span>(<span>self, player: <a title="katan_ai.katan.player.Player" href="../player.html#katan_ai.katan.player.Player">Player</a>, ensure_connected: Optional[bool] = True) ‑> Set[<a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all the valid settlement coordinates for the player to build a settlement.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player to check for valid settlement coordinates</dd>
<dt><strong><code>ensure_connected</code></strong></dt>
<dd>Whether to ensure the coordinates are connected to the player's roads</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The coordinates of all the valid settlement intersections</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_settlement_coords(
    self, player: Player, ensure_connected: Optional[bool] = True
) -&gt; Set[Coords]:
    &#34;&#34;&#34;Get all the valid settlement coordinates for the player to build a settlement.

    Args:
        player: The player to check for valid settlement coordinates
        ensure_connected: Whether to ensure the coordinates are connected to the player&#39;s roads
    Returns:
        The coordinates of all the valid settlement intersections
    &#34;&#34;&#34;
    return set(
        [
            i
            for i in self.intersections.keys()
            if self.is_valid_settlement_coords(player, i, ensure_connected)
        ]
    )</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.get_yield_for_roll"><code class="name flex">
<span>def <span class="ident">get_yield_for_roll</span></span>(<span>self, roll: int) ‑> Dict[<a title="katan_ai.katan.player.Player" href="../player.html#katan_ai.katan.player.Player">Player</a>, <a title="katan_ai.katan.roll_yield.RollYield" href="../roll_yield.html#katan_ai.katan.roll_yield.RollYield">RollYield</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the resources given out for a particular roll.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>roll</code></strong></dt>
<dd>The number rolled</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The RollYield object containing the information for what each player gets, keyed by the player</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_yield_for_roll(self, roll: int) -&gt; Dict[Player, RollYield]:
    &#34;&#34;&#34;Calculate the resources given out for a particular roll.

    Args:
        roll: The number rolled
    Returns:
        The RollYield object containing the information for what each player gets, keyed by the player
    &#34;&#34;&#34;
    total_yield: Dict[Player, RollYield] = {}
    for hex in self.hexes.values():
        if hex.token_number == roll and self.robber != hex.coords:
            resource = hex.hex_type.get_resource()
            # Check around the hex for any settlements/cities
            for intersection in self.get_connected_hex_intersections(hex):
                if intersection.building is not None:
                    owner = intersection.building.owner
                    if owner not in total_yield.keys():
                        total_yield[owner] = RollYield()
                    amount = (
                        2
                        if intersection.building.building_type is BuildingType.CITY
                        else 1
                    )
                    total_yield[owner].add_yield(
                        resource,
                        amount,
                        source=RollYieldSource(
                            resource,
                            amount,
                            intersection.building,
                            hex,
                        ),
                    )
    return total_yield</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.is_valid_city_coords"><code class="name flex">
<span>def <span class="ident">is_valid_city_coords</span></span>(<span>self, player: <a title="katan_ai.katan.player.Player" href="../player.html#katan_ai.katan.player.Player">Player</a>, coords: <a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether the coordinates given are valid city coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player</dd>
<dt><strong><code>coords</code></strong></dt>
<dd>The coordinates to check</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the coords are a valid place for the player to build a city</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid_city_coords(self, player: Player, coords: Coords) -&gt; bool:
    &#34;&#34;&#34;Check whether the coordinates given are valid city coordinates.

    Args:
        player: The player
        coords: The coordinates to check
    Returns:
        Whether the coords are a valid place for the player to build a city
    &#34;&#34;&#34;
    try:
        self.assert_valid_city_coords(player=player, coords=coords)
    except:  # noqa: E722
        return False
    return True</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.is_valid_hex_coords"><code class="name flex">
<span>def <span class="ident">is_valid_hex_coords</span></span>(<span>self, coords: <a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether the coordinates given are valid hex coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coords</code></strong></dt>
<dd>The coordinates</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether there is a hex at those coordinates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid_hex_coords(self, coords: Coords) -&gt; bool:
    &#34;&#34;&#34;Check whether the coordinates given are valid hex coordinates.

    Args:
        coords: The coordinates
    Returns:
        Whether there is a hex at those coordinates
    &#34;&#34;&#34;
    return len(set(filter(lambda x: x == coords, self.hexes.keys()))) != 0</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.is_valid_road_coords"><code class="name flex">
<span>def <span class="ident">is_valid_road_coords</span></span>(<span>self, player: <a title="katan_ai.katan.player.Player" href="../player.html#katan_ai.katan.player.Player">Player</a>, path_coords: Set[<a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>], ensure_connected: Optional[bool] = True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether the path coordinates given are valid road coordinate for the player given.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player</dd>
<dt><strong><code>path_coords</code></strong></dt>
<dd>The coordinates of the path</dd>
<dt><strong><code>ensure_connected</code></strong></dt>
<dd>Whether to ensure that the road is connected to the player's existing roads/buildings. Defaults to True</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the player can build a road on this path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid_road_coords(
    self,
    player: Player,
    path_coords: Set[Coords],
    ensure_connected: Optional[bool] = True,
) -&gt; bool:
    &#34;&#34;&#34;Check whether the path coordinates given are valid road coordinate for the player given.

    Args:
        player: The player
        path_coords: The coordinates of the path
        ensure_connected: Whether to ensure that the road is connected to the player&#39;s existing roads/buildings. Defaults to True
    Returns:
        Whether the player can build a road on this path
    &#34;&#34;&#34;
    try:
        self.assert_valid_road_coords(
            player, path_coords, ensure_connected=ensure_connected
        )
    except:  # noqa: E722
        return False
    return True</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.board.board.Board.is_valid_settlement_coords"><code class="name flex">
<span>def <span class="ident">is_valid_settlement_coords</span></span>(<span>self, player: <a title="katan_ai.katan.player.Player" href="../player.html#katan_ai.katan.player.Player">Player</a>, coords: <a title="katan_ai.katan.board.coords.Coords" href="coords.html#katan_ai.katan.board.coords.Coords">Coords</a>, ensure_connected: Optional[bool]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether the given coordinates are a valid place for the player to build a settlement.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player</dd>
<dt><strong><code>coords</code></strong></dt>
<dd>The coordinates to check</dd>
<dt><strong><code>ensure_connected</code></strong></dt>
<dd>Whether to ensure that the settlement will be connected to the player's roads</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the coordinates are a valid settlement location for the player</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid_settlement_coords(
    self, player: Player, coords: Coords, ensure_connected: Optional[bool]
) -&gt; bool:
    &#34;&#34;&#34;Check whether the given coordinates are a valid place for the player to build a settlement.

    Args:
        player: The player
        coords: The coordinates to check
        ensure_connected: Whether to ensure that the settlement will be connected to the player&#39;s roads
    Returns:
        Whether the coordinates are a valid settlement location for the player
    &#34;&#34;&#34;
    try:
        self.assert_valid_settlement_coords(
            player=player, coords=coords, ensure_connected=ensure_connected
        )
    except:  # noqa: E722
        return False
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="katan_ai.katan.board" href="index.html">katan_ai.katan.board</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="katan_ai.katan.board.board.Board" href="#katan_ai.katan.board.board.Board">Board</a></code></h4>
<ul class="">
<li><code><a title="katan_ai.katan.board.board.Board.add_intersection_building" href="#katan_ai.katan.board.board.Board.add_intersection_building">add_intersection_building</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.add_path_building" href="#katan_ai.katan.board.board.Board.add_path_building">add_path_building</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.assert_valid_city_coords" href="#katan_ai.katan.board.board.Board.assert_valid_city_coords">assert_valid_city_coords</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.assert_valid_road_coords" href="#katan_ai.katan.board.board.Board.assert_valid_road_coords">assert_valid_road_coords</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.assert_valid_settlement_coords" href="#katan_ai.katan.board.board.Board.assert_valid_settlement_coords">assert_valid_settlement_coords</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.calculate_player_longest_road" href="#katan_ai.katan.board.board.Board.calculate_player_longest_road">calculate_player_longest_road</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.get_connected_hex_intersections" href="#katan_ai.katan.board.board.Board.get_connected_hex_intersections">get_connected_hex_intersections</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.get_hex_resources_for_intersection" href="#katan_ai.katan.board.board.Board.get_hex_resources_for_intersection">get_hex_resources_for_intersection</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.get_hexes_connected_to_intersection" href="#katan_ai.katan.board.board.Board.get_hexes_connected_to_intersection">get_hexes_connected_to_intersection</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.get_intersection_connected_intersections" href="#katan_ai.katan.board.board.Board.get_intersection_connected_intersections">get_intersection_connected_intersections</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.get_paths_for_intersection_coords" href="#katan_ai.katan.board.board.Board.get_paths_for_intersection_coords">get_paths_for_intersection_coords</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.get_players_on_hex" href="#katan_ai.katan.board.board.Board.get_players_on_hex">get_players_on_hex</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.get_valid_city_coords" href="#katan_ai.katan.board.board.Board.get_valid_city_coords">get_valid_city_coords</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.get_valid_road_coords" href="#katan_ai.katan.board.board.Board.get_valid_road_coords">get_valid_road_coords</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.get_valid_settlement_coords" href="#katan_ai.katan.board.board.Board.get_valid_settlement_coords">get_valid_settlement_coords</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.get_yield_for_roll" href="#katan_ai.katan.board.board.Board.get_yield_for_roll">get_yield_for_roll</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.is_valid_city_coords" href="#katan_ai.katan.board.board.Board.is_valid_city_coords">is_valid_city_coords</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.is_valid_hex_coords" href="#katan_ai.katan.board.board.Board.is_valid_hex_coords">is_valid_hex_coords</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.is_valid_road_coords" href="#katan_ai.katan.board.board.Board.is_valid_road_coords">is_valid_road_coords</a></code></li>
<li><code><a title="katan_ai.katan.board.board.Board.is_valid_settlement_coords" href="#katan_ai.katan.board.board.Board.is_valid_settlement_coords">is_valid_settlement_coords</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
