<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>katan_ai.katan.game API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>katan_ai.katan.game</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from random import shuffle
from typing import Dict, Optional, Set

from katan_ai.katan.board.board import Board
from katan_ai.katan.board.building_type import BuildingType
from katan_ai.katan.board.coords import Coords
from katan_ai.katan.development_card import DevelopmentCard
from katan_ai.katan.errors import NotEnoughResourcesError
from katan_ai.katan.player import Player
from katan_ai.katan.roll_yield import RollYield


class Game:
    &#34;&#34;&#34;A game of Catan. Holds all the game state and game logic for interacting with the board, players and decks.

    Args:
            board: The board to use in the Catan game
            num_players: The number of players to start the game with. Defaults to 4

    Attributes:
            board (Board): The Catan board being used in this game
            players (List[Player]): The players in the game, ordered by (recommended) turn order
            longest_road_owner (Player): The player who has the longest road token, or None if no players
                have a road of at least 5 length
            largest_army_owner (Player): The player how has the largest army, or None if no players have played at least 3 knight cards
            development_card_deck (List[DevelopmentCard]): The deck of development cards
    &#34;&#34;&#34;

    def __init__(self, board: Board, num_players: Optional[int] = 4):
        &#34;&#34;&#34;Initialize game based off of a given board setup and number of players&#34;&#34;&#34;
        self.board = board
        self.players = [Player() for i in range(num_players)]
        self.longest_road_owner = None
        self.largest_army_owner = None
        self.development_card_deck = (
            14 * [DevelopmentCard.KNIGHT]
            + 5 * [DevelopmentCard.VICTORY_POINT]
            + 2 * [DevelopmentCard.ROAD_BUILDING]
            + 2 * [DevelopmentCard.YEAR_OF_PLENTY]
            + 2 * [DevelopmentCard.MONOPOLY]
        )

        shuffle(self.development_card_deck)

    def build_settlement(
        self,
        player: Player,
        coords: Coords,
        cost_resources: Optional[bool] = True,
        ensure_connected: Optional[bool] = True,
    ):
        &#34;&#34;&#34;Build a settlement by the player given in the coords given, or raises an error if the input is invalid.

        Args:
            player: The player who is building the settlement
            coords: The coordinates to build the settlement at
            cost_resources: Whether to remove the resources required to build a settlement from the player&#39;s hands, and
                raise an error if they don&#39;t have them. Defaults to True
            ensure_connection: Whether to raise an error if the settlement would not be connected to a road owned by the same
                player. Defaults to True
        Raises:
            NotEnoughResourcesError: If check_resources is True and the player does not have enough resources
            NotConnectedError: If check_connection is True and the settlement would not be connected to any roads owned by the player
        &#34;&#34;&#34;
        # Check the player has the resources
        if cost_resources and not player.has_resources(
            BuildingType.SETTLEMENT.get_required_resources()
        ):
            raise NotEnoughResourcesError(
                &#34;Player does not have enough resources to build a settlement&#34;
            )
        # Build the settlement
        self.board.add_intersection_building(
            player, coords, BuildingType.SETTLEMENT, ensure_connected=ensure_connected
        )
        # Remove the resources
        if cost_resources:
            player.remove_resources(BuildingType.SETTLEMENT.get_required_resources())

    def build_road(
        self,
        player: Player,
        path_coords: Set[Coords],
        cost_resources: Optional[bool] = True,
        ensure_connected: Optional[bool] = True,
    ):
        &#34;&#34;&#34;Build a road.

        Args:
            player: The player who is building the road
            path_coords: The coordinates of the path to build a road on.
                Should be two valid connected intersection coordinates (i.e. {(1, 0), (1, -1)})
            cost_resources: Whether to remove resources from the player&#39;s hand to build the road,
                and raise an error if they don&#39;t have enough
            ensure_connected: Whether to ensure that the road is connected to another road, settlement or city
        Raises:
            NotEnoughResourcesError: If check_resources is True and the player doesn&#39;t have the cards to build the road
            NotConnectedError: If check_connection is True and the road is not connected to anything
            ValueError: If path_coords is not a set of two valid intersection coordinates
            CoordsBlockedError: If the position is already blocked by another road/other path building
        &#34;&#34;&#34;
        # Check the player has the resources
        if cost_resources and not player.has_resources(
            BuildingType.ROAD.get_required_resources()
        ):
            raise NotEnoughResourcesError(
                &#34;Player doesn not have the resources to build a road&#34;
            )
        self.board.add_path_building(
            player=player,
            path_coords=path_coords,
            building_type=BuildingType.ROAD,
            ensure_connected=ensure_connected,
        )
        # Remove the resources
        if cost_resources:
            player.remove_resources(BuildingType.ROAD.get_required_resources())

        # Check if the player gets longest road
        road_length = self.board.calculate_player_longest_road(player)
        if road_length &gt;= 5 and (
            self.longest_road_owner is None
            or road_length
            &gt; self.board.calculate_player_longest_road(self.longest_road_owner)
        ):
            self.longest_road_owner = player

    def upgrade_settlement_to_city(
        self, player: Player, coords: Coords, cost_resources: Optional[bool] = True
    ):
        &#34;&#34;&#34;Build a city from a settlement.

        Args:
            player: The player who is building the city
            coords: Where to build the city
            cost_resources: Whether to remove the resources from the player&#39;s hand
        Raises:
            NotEnoughResourcesError: If cost_resources is true and the player doesn&#39;t have enough resources
            ValueError: If coords is not a valid intersection
            RequiresSettlementError: If there is not a valid settlement at the intersection to upgrade
        &#34;&#34;&#34;
        if cost_resources and not player.has_resources(
            BuildingType.CITY.get_required_resources()
        ):
            raise NotEnoughResourcesError(
                &#34;Player does not have the resources to build a city&#34;
            )

        self.board.add_intersection_building(
            player=player, coords=coords, building_type=BuildingType.CITY
        )

        if cost_resources:
            player.remove_resources(BuildingType.CITY.get_required_resources())

    def add_yield_for_roll(self, roll: int):
        &#34;&#34;&#34;Add the resources to the player&#39;s hands for the dice roll given.

        Args:
            roll: The number that was rolled
        &#34;&#34;&#34;
        self.add_yield(self.board.get_yield_for_roll(roll))

    def add_yield(self, roll_yield: Dict[Player, RollYield]):
        &#34;&#34;&#34;Add the yield provided to the player&#39;s hands.

        Args:
            roll_yield: The yield provided by Board.get_yield_for_roll. A dictionary of RollYields mapped by
                the player who gets that yield
        &#34;&#34;&#34;
        for p, y in roll_yield.items():
            p.add_resources(y.total_yield)

    def move_robber(self, coords: Coords):
        &#34;&#34;&#34;Move the robber to the coords specified.

        Args:
            coords: The coordinates of the hex to move the robber to
        Raises:
            ValueError: If the coordinates are not a valid hex
        &#34;&#34;&#34;
        if not self.board.is_valid_hex_coords(coords):
            raise ValueError(&#34;coords is no a valid hex coordinate&#34;)

        self.board.robber = coords

    def build_development_card(self, player: Player) -&gt; DevelopmentCard:
        &#34;&#34;&#34;Build a development card and place it in the player&#39;s hand.

        Args:
            player: The player building the development card
        Raises:
            NotEnoughResourcesError: If the player cannot afford to build a development card
        Returns:
            The card that the player built and has been added to their hand
        &#34;&#34;&#34;
        if not player.has_resources(DevelopmentCard.get_required_resources()):
            raise NotEnoughResourcesError(
                &#34;Player does not have enough resources to build a development card&#34;
            )

        card = self.development_card_deck.pop(0)
        player.development_cards[card] += 1
        player.remove_resources(DevelopmentCard.get_required_resources())
        return card

    def play_development_card(self, player: Player, card: DevelopmentCard):
        &#34;&#34;&#34;Play a development card.

        Do not actually change the game state to play the card.
        Mainly just keep track of how many knight cards each player has played and may change who has the largest army

        Args:
            player: The player playing a development card
            card: The development card they are playing
        Raises:
            ValueError: If the player does not have the card
        &#34;&#34;&#34;
        player.play_development_card(card)
        if card is DevelopmentCard.KNIGHT:
            player.number_played_knights += 1
            if player.number_played_knights &gt;= 3 and (
                self.largest_army_owner is None
                or self.largest_army_owner.number_played_knights
                &lt; player.number_played_knights
            ):
                self.largest_army_owner = player

    def get_victory_points(self, player: Player):
        &#34;&#34;&#34;Get the number of victory points the player has.

        Args:
            player: The player to get the victory points for
        Returns:
            The number of victory points
        &#34;&#34;&#34;
        victory_points = sum(
            list(
                map(
                    lambda c: 2 if c.building.building_type is BuildingType.CITY else 1,
                    [
                        c
                        for c in self.board.intersections.values()
                        if c.building is not None and c.building.owner is player
                    ],
                )
            )
        )
        if player is self.longest_road_owner:
            victory_points += 2
        if player is self.largest_army_owner:
            victory_points += 2

        return victory_points + player.development_cards[DevelopmentCard.VICTORY_POINT]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="katan_ai.katan.game.Game"><code class="flex name class">
<span>class <span class="ident">Game</span></span>
<span>(</span><span>board: <a title="katan_ai.katan.board.board.Board" href="board/board.html#katan_ai.katan.board.board.Board">Board</a>, num_players: Optional[int] = 4)</span>
</code></dt>
<dd>
<div class="desc"><p>A game of Catan. Holds all the game state and game logic for interacting with the board, players and decks.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>board</code></strong></dt>
<dd>The board to use in the Catan game</dd>
<dt><strong><code>num_players</code></strong></dt>
<dd>The number of players to start the game with. Defaults to 4</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>board</code></strong> :&ensp;<code>Board</code></dt>
<dd>The Catan board being used in this game</dd>
<dt><strong><code>players</code></strong> :&ensp;<code>List[Player]</code></dt>
<dd>The players in the game, ordered by (recommended) turn order</dd>
<dt><strong><code>longest_road_owner</code></strong> :&ensp;<code>Player</code></dt>
<dd>The player who has the longest road token, or None if no players
have a road of at least 5 length</dd>
<dt><strong><code>largest_army_owner</code></strong> :&ensp;<code>Player</code></dt>
<dd>The player how has the largest army, or None if no players have played at least 3 knight cards</dd>
<dt><strong><code>development_card_deck</code></strong> :&ensp;<code>List[DevelopmentCard]</code></dt>
<dd>The deck of development cards</dd>
</dl>
<p>Initialize game based off of a given board setup and number of players</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Game:
    &#34;&#34;&#34;A game of Catan. Holds all the game state and game logic for interacting with the board, players and decks.

    Args:
            board: The board to use in the Catan game
            num_players: The number of players to start the game with. Defaults to 4

    Attributes:
            board (Board): The Catan board being used in this game
            players (List[Player]): The players in the game, ordered by (recommended) turn order
            longest_road_owner (Player): The player who has the longest road token, or None if no players
                have a road of at least 5 length
            largest_army_owner (Player): The player how has the largest army, or None if no players have played at least 3 knight cards
            development_card_deck (List[DevelopmentCard]): The deck of development cards
    &#34;&#34;&#34;

    def __init__(self, board: Board, num_players: Optional[int] = 4):
        &#34;&#34;&#34;Initialize game based off of a given board setup and number of players&#34;&#34;&#34;
        self.board = board
        self.players = [Player() for i in range(num_players)]
        self.longest_road_owner = None
        self.largest_army_owner = None
        self.development_card_deck = (
            14 * [DevelopmentCard.KNIGHT]
            + 5 * [DevelopmentCard.VICTORY_POINT]
            + 2 * [DevelopmentCard.ROAD_BUILDING]
            + 2 * [DevelopmentCard.YEAR_OF_PLENTY]
            + 2 * [DevelopmentCard.MONOPOLY]
        )

        shuffle(self.development_card_deck)

    def build_settlement(
        self,
        player: Player,
        coords: Coords,
        cost_resources: Optional[bool] = True,
        ensure_connected: Optional[bool] = True,
    ):
        &#34;&#34;&#34;Build a settlement by the player given in the coords given, or raises an error if the input is invalid.

        Args:
            player: The player who is building the settlement
            coords: The coordinates to build the settlement at
            cost_resources: Whether to remove the resources required to build a settlement from the player&#39;s hands, and
                raise an error if they don&#39;t have them. Defaults to True
            ensure_connection: Whether to raise an error if the settlement would not be connected to a road owned by the same
                player. Defaults to True
        Raises:
            NotEnoughResourcesError: If check_resources is True and the player does not have enough resources
            NotConnectedError: If check_connection is True and the settlement would not be connected to any roads owned by the player
        &#34;&#34;&#34;
        # Check the player has the resources
        if cost_resources and not player.has_resources(
            BuildingType.SETTLEMENT.get_required_resources()
        ):
            raise NotEnoughResourcesError(
                &#34;Player does not have enough resources to build a settlement&#34;
            )
        # Build the settlement
        self.board.add_intersection_building(
            player, coords, BuildingType.SETTLEMENT, ensure_connected=ensure_connected
        )
        # Remove the resources
        if cost_resources:
            player.remove_resources(BuildingType.SETTLEMENT.get_required_resources())

    def build_road(
        self,
        player: Player,
        path_coords: Set[Coords],
        cost_resources: Optional[bool] = True,
        ensure_connected: Optional[bool] = True,
    ):
        &#34;&#34;&#34;Build a road.

        Args:
            player: The player who is building the road
            path_coords: The coordinates of the path to build a road on.
                Should be two valid connected intersection coordinates (i.e. {(1, 0), (1, -1)})
            cost_resources: Whether to remove resources from the player&#39;s hand to build the road,
                and raise an error if they don&#39;t have enough
            ensure_connected: Whether to ensure that the road is connected to another road, settlement or city
        Raises:
            NotEnoughResourcesError: If check_resources is True and the player doesn&#39;t have the cards to build the road
            NotConnectedError: If check_connection is True and the road is not connected to anything
            ValueError: If path_coords is not a set of two valid intersection coordinates
            CoordsBlockedError: If the position is already blocked by another road/other path building
        &#34;&#34;&#34;
        # Check the player has the resources
        if cost_resources and not player.has_resources(
            BuildingType.ROAD.get_required_resources()
        ):
            raise NotEnoughResourcesError(
                &#34;Player doesn not have the resources to build a road&#34;
            )
        self.board.add_path_building(
            player=player,
            path_coords=path_coords,
            building_type=BuildingType.ROAD,
            ensure_connected=ensure_connected,
        )
        # Remove the resources
        if cost_resources:
            player.remove_resources(BuildingType.ROAD.get_required_resources())

        # Check if the player gets longest road
        road_length = self.board.calculate_player_longest_road(player)
        if road_length &gt;= 5 and (
            self.longest_road_owner is None
            or road_length
            &gt; self.board.calculate_player_longest_road(self.longest_road_owner)
        ):
            self.longest_road_owner = player

    def upgrade_settlement_to_city(
        self, player: Player, coords: Coords, cost_resources: Optional[bool] = True
    ):
        &#34;&#34;&#34;Build a city from a settlement.

        Args:
            player: The player who is building the city
            coords: Where to build the city
            cost_resources: Whether to remove the resources from the player&#39;s hand
        Raises:
            NotEnoughResourcesError: If cost_resources is true and the player doesn&#39;t have enough resources
            ValueError: If coords is not a valid intersection
            RequiresSettlementError: If there is not a valid settlement at the intersection to upgrade
        &#34;&#34;&#34;
        if cost_resources and not player.has_resources(
            BuildingType.CITY.get_required_resources()
        ):
            raise NotEnoughResourcesError(
                &#34;Player does not have the resources to build a city&#34;
            )

        self.board.add_intersection_building(
            player=player, coords=coords, building_type=BuildingType.CITY
        )

        if cost_resources:
            player.remove_resources(BuildingType.CITY.get_required_resources())

    def add_yield_for_roll(self, roll: int):
        &#34;&#34;&#34;Add the resources to the player&#39;s hands for the dice roll given.

        Args:
            roll: The number that was rolled
        &#34;&#34;&#34;
        self.add_yield(self.board.get_yield_for_roll(roll))

    def add_yield(self, roll_yield: Dict[Player, RollYield]):
        &#34;&#34;&#34;Add the yield provided to the player&#39;s hands.

        Args:
            roll_yield: The yield provided by Board.get_yield_for_roll. A dictionary of RollYields mapped by
                the player who gets that yield
        &#34;&#34;&#34;
        for p, y in roll_yield.items():
            p.add_resources(y.total_yield)

    def move_robber(self, coords: Coords):
        &#34;&#34;&#34;Move the robber to the coords specified.

        Args:
            coords: The coordinates of the hex to move the robber to
        Raises:
            ValueError: If the coordinates are not a valid hex
        &#34;&#34;&#34;
        if not self.board.is_valid_hex_coords(coords):
            raise ValueError(&#34;coords is no a valid hex coordinate&#34;)

        self.board.robber = coords

    def build_development_card(self, player: Player) -&gt; DevelopmentCard:
        &#34;&#34;&#34;Build a development card and place it in the player&#39;s hand.

        Args:
            player: The player building the development card
        Raises:
            NotEnoughResourcesError: If the player cannot afford to build a development card
        Returns:
            The card that the player built and has been added to their hand
        &#34;&#34;&#34;
        if not player.has_resources(DevelopmentCard.get_required_resources()):
            raise NotEnoughResourcesError(
                &#34;Player does not have enough resources to build a development card&#34;
            )

        card = self.development_card_deck.pop(0)
        player.development_cards[card] += 1
        player.remove_resources(DevelopmentCard.get_required_resources())
        return card

    def play_development_card(self, player: Player, card: DevelopmentCard):
        &#34;&#34;&#34;Play a development card.

        Do not actually change the game state to play the card.
        Mainly just keep track of how many knight cards each player has played and may change who has the largest army

        Args:
            player: The player playing a development card
            card: The development card they are playing
        Raises:
            ValueError: If the player does not have the card
        &#34;&#34;&#34;
        player.play_development_card(card)
        if card is DevelopmentCard.KNIGHT:
            player.number_played_knights += 1
            if player.number_played_knights &gt;= 3 and (
                self.largest_army_owner is None
                or self.largest_army_owner.number_played_knights
                &lt; player.number_played_knights
            ):
                self.largest_army_owner = player

    def get_victory_points(self, player: Player):
        &#34;&#34;&#34;Get the number of victory points the player has.

        Args:
            player: The player to get the victory points for
        Returns:
            The number of victory points
        &#34;&#34;&#34;
        victory_points = sum(
            list(
                map(
                    lambda c: 2 if c.building.building_type is BuildingType.CITY else 1,
                    [
                        c
                        for c in self.board.intersections.values()
                        if c.building is not None and c.building.owner is player
                    ],
                )
            )
        )
        if player is self.longest_road_owner:
            victory_points += 2
        if player is self.largest_army_owner:
            victory_points += 2

        return victory_points + player.development_cards[DevelopmentCard.VICTORY_POINT]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="katan_ai.katan.game.Game.add_yield"><code class="name flex">
<span>def <span class="ident">add_yield</span></span>(<span>self, roll_yield: Dict[<a title="katan_ai.katan.player.Player" href="player.html#katan_ai.katan.player.Player">Player</a>, <a title="katan_ai.katan.roll_yield.RollYield" href="roll_yield.html#katan_ai.katan.roll_yield.RollYield">RollYield</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Add the yield provided to the player's hands.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>roll_yield</code></strong></dt>
<dd>The yield provided by Board.get_yield_for_roll. A dictionary of RollYields mapped by
the player who gets that yield</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_yield(self, roll_yield: Dict[Player, RollYield]):
    &#34;&#34;&#34;Add the yield provided to the player&#39;s hands.

    Args:
        roll_yield: The yield provided by Board.get_yield_for_roll. A dictionary of RollYields mapped by
            the player who gets that yield
    &#34;&#34;&#34;
    for p, y in roll_yield.items():
        p.add_resources(y.total_yield)</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.game.Game.add_yield_for_roll"><code class="name flex">
<span>def <span class="ident">add_yield_for_roll</span></span>(<span>self, roll: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the resources to the player's hands for the dice roll given.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>roll</code></strong></dt>
<dd>The number that was rolled</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_yield_for_roll(self, roll: int):
    &#34;&#34;&#34;Add the resources to the player&#39;s hands for the dice roll given.

    Args:
        roll: The number that was rolled
    &#34;&#34;&#34;
    self.add_yield(self.board.get_yield_for_roll(roll))</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.game.Game.build_development_card"><code class="name flex">
<span>def <span class="ident">build_development_card</span></span>(<span>self, player: <a title="katan_ai.katan.player.Player" href="player.html#katan_ai.katan.player.Player">Player</a>) ‑> <a title="katan_ai.katan.development_card.DevelopmentCard" href="development_card.html#katan_ai.katan.development_card.DevelopmentCard">DevelopmentCard</a></span>
</code></dt>
<dd>
<div class="desc"><p>Build a development card and place it in the player's hand.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player building the development card</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotEnoughResourcesError</code></dt>
<dd>If the player cannot afford to build a development card</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The card that the player built and has been added to their hand</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_development_card(self, player: Player) -&gt; DevelopmentCard:
    &#34;&#34;&#34;Build a development card and place it in the player&#39;s hand.

    Args:
        player: The player building the development card
    Raises:
        NotEnoughResourcesError: If the player cannot afford to build a development card
    Returns:
        The card that the player built and has been added to their hand
    &#34;&#34;&#34;
    if not player.has_resources(DevelopmentCard.get_required_resources()):
        raise NotEnoughResourcesError(
            &#34;Player does not have enough resources to build a development card&#34;
        )

    card = self.development_card_deck.pop(0)
    player.development_cards[card] += 1
    player.remove_resources(DevelopmentCard.get_required_resources())
    return card</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.game.Game.build_road"><code class="name flex">
<span>def <span class="ident">build_road</span></span>(<span>self, player: <a title="katan_ai.katan.player.Player" href="player.html#katan_ai.katan.player.Player">Player</a>, path_coords: Set[<a title="katan_ai.katan.board.coords.Coords" href="board/coords.html#katan_ai.katan.board.coords.Coords">Coords</a>], cost_resources: Optional[bool] = True, ensure_connected: Optional[bool] = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Build a road.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player who is building the road</dd>
<dt><strong><code>path_coords</code></strong></dt>
<dd>The coordinates of the path to build a road on.
Should be two valid connected intersection coordinates (i.e. {(1, 0), (1, -1)})</dd>
<dt><strong><code>cost_resources</code></strong></dt>
<dd>Whether to remove resources from the player's hand to build the road,
and raise an error if they don't have enough</dd>
<dt><strong><code>ensure_connected</code></strong></dt>
<dd>Whether to ensure that the road is connected to another road, settlement or city</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotEnoughResourcesError</code></dt>
<dd>If check_resources is True and the player doesn't have the cards to build the road</dd>
<dt><code>NotConnectedError</code></dt>
<dd>If check_connection is True and the road is not connected to anything</dd>
<dt><code>ValueError</code></dt>
<dd>If path_coords is not a set of two valid intersection coordinates</dd>
<dt><code>CoordsBlockedError</code></dt>
<dd>If the position is already blocked by another road/other path building</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_road(
    self,
    player: Player,
    path_coords: Set[Coords],
    cost_resources: Optional[bool] = True,
    ensure_connected: Optional[bool] = True,
):
    &#34;&#34;&#34;Build a road.

    Args:
        player: The player who is building the road
        path_coords: The coordinates of the path to build a road on.
            Should be two valid connected intersection coordinates (i.e. {(1, 0), (1, -1)})
        cost_resources: Whether to remove resources from the player&#39;s hand to build the road,
            and raise an error if they don&#39;t have enough
        ensure_connected: Whether to ensure that the road is connected to another road, settlement or city
    Raises:
        NotEnoughResourcesError: If check_resources is True and the player doesn&#39;t have the cards to build the road
        NotConnectedError: If check_connection is True and the road is not connected to anything
        ValueError: If path_coords is not a set of two valid intersection coordinates
        CoordsBlockedError: If the position is already blocked by another road/other path building
    &#34;&#34;&#34;
    # Check the player has the resources
    if cost_resources and not player.has_resources(
        BuildingType.ROAD.get_required_resources()
    ):
        raise NotEnoughResourcesError(
            &#34;Player doesn not have the resources to build a road&#34;
        )
    self.board.add_path_building(
        player=player,
        path_coords=path_coords,
        building_type=BuildingType.ROAD,
        ensure_connected=ensure_connected,
    )
    # Remove the resources
    if cost_resources:
        player.remove_resources(BuildingType.ROAD.get_required_resources())

    # Check if the player gets longest road
    road_length = self.board.calculate_player_longest_road(player)
    if road_length &gt;= 5 and (
        self.longest_road_owner is None
        or road_length
        &gt; self.board.calculate_player_longest_road(self.longest_road_owner)
    ):
        self.longest_road_owner = player</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.game.Game.build_settlement"><code class="name flex">
<span>def <span class="ident">build_settlement</span></span>(<span>self, player: <a title="katan_ai.katan.player.Player" href="player.html#katan_ai.katan.player.Player">Player</a>, coords: <a title="katan_ai.katan.board.coords.Coords" href="board/coords.html#katan_ai.katan.board.coords.Coords">Coords</a>, cost_resources: Optional[bool] = True, ensure_connected: Optional[bool] = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Build a settlement by the player given in the coords given, or raises an error if the input is invalid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player who is building the settlement</dd>
<dt><strong><code>coords</code></strong></dt>
<dd>The coordinates to build the settlement at</dd>
<dt><strong><code>cost_resources</code></strong></dt>
<dd>Whether to remove the resources required to build a settlement from the player's hands, and
raise an error if they don't have them. Defaults to True</dd>
<dt><strong><code>ensure_connection</code></strong></dt>
<dd>Whether to raise an error if the settlement would not be connected to a road owned by the same
player. Defaults to True</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotEnoughResourcesError</code></dt>
<dd>If check_resources is True and the player does not have enough resources</dd>
<dt><code>NotConnectedError</code></dt>
<dd>If check_connection is True and the settlement would not be connected to any roads owned by the player</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_settlement(
    self,
    player: Player,
    coords: Coords,
    cost_resources: Optional[bool] = True,
    ensure_connected: Optional[bool] = True,
):
    &#34;&#34;&#34;Build a settlement by the player given in the coords given, or raises an error if the input is invalid.

    Args:
        player: The player who is building the settlement
        coords: The coordinates to build the settlement at
        cost_resources: Whether to remove the resources required to build a settlement from the player&#39;s hands, and
            raise an error if they don&#39;t have them. Defaults to True
        ensure_connection: Whether to raise an error if the settlement would not be connected to a road owned by the same
            player. Defaults to True
    Raises:
        NotEnoughResourcesError: If check_resources is True and the player does not have enough resources
        NotConnectedError: If check_connection is True and the settlement would not be connected to any roads owned by the player
    &#34;&#34;&#34;
    # Check the player has the resources
    if cost_resources and not player.has_resources(
        BuildingType.SETTLEMENT.get_required_resources()
    ):
        raise NotEnoughResourcesError(
            &#34;Player does not have enough resources to build a settlement&#34;
        )
    # Build the settlement
    self.board.add_intersection_building(
        player, coords, BuildingType.SETTLEMENT, ensure_connected=ensure_connected
    )
    # Remove the resources
    if cost_resources:
        player.remove_resources(BuildingType.SETTLEMENT.get_required_resources())</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.game.Game.get_victory_points"><code class="name flex">
<span>def <span class="ident">get_victory_points</span></span>(<span>self, player: <a title="katan_ai.katan.player.Player" href="player.html#katan_ai.katan.player.Player">Player</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the number of victory points the player has.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player to get the victory points for</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of victory points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_victory_points(self, player: Player):
    &#34;&#34;&#34;Get the number of victory points the player has.

    Args:
        player: The player to get the victory points for
    Returns:
        The number of victory points
    &#34;&#34;&#34;
    victory_points = sum(
        list(
            map(
                lambda c: 2 if c.building.building_type is BuildingType.CITY else 1,
                [
                    c
                    for c in self.board.intersections.values()
                    if c.building is not None and c.building.owner is player
                ],
            )
        )
    )
    if player is self.longest_road_owner:
        victory_points += 2
    if player is self.largest_army_owner:
        victory_points += 2

    return victory_points + player.development_cards[DevelopmentCard.VICTORY_POINT]</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.game.Game.move_robber"><code class="name flex">
<span>def <span class="ident">move_robber</span></span>(<span>self, coords: <a title="katan_ai.katan.board.coords.Coords" href="board/coords.html#katan_ai.katan.board.coords.Coords">Coords</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the robber to the coords specified.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coords</code></strong></dt>
<dd>The coordinates of the hex to move the robber to</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the coordinates are not a valid hex</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_robber(self, coords: Coords):
    &#34;&#34;&#34;Move the robber to the coords specified.

    Args:
        coords: The coordinates of the hex to move the robber to
    Raises:
        ValueError: If the coordinates are not a valid hex
    &#34;&#34;&#34;
    if not self.board.is_valid_hex_coords(coords):
        raise ValueError(&#34;coords is no a valid hex coordinate&#34;)

    self.board.robber = coords</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.game.Game.play_development_card"><code class="name flex">
<span>def <span class="ident">play_development_card</span></span>(<span>self, player: <a title="katan_ai.katan.player.Player" href="player.html#katan_ai.katan.player.Player">Player</a>, card: <a title="katan_ai.katan.development_card.DevelopmentCard" href="development_card.html#katan_ai.katan.development_card.DevelopmentCard">DevelopmentCard</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Play a development card.</p>
<p>Do not actually change the game state to play the card.
Mainly just keep track of how many knight cards each player has played and may change who has the largest army</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player playing a development card</dd>
<dt><strong><code>card</code></strong></dt>
<dd>The development card they are playing</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the player does not have the card</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play_development_card(self, player: Player, card: DevelopmentCard):
    &#34;&#34;&#34;Play a development card.

    Do not actually change the game state to play the card.
    Mainly just keep track of how many knight cards each player has played and may change who has the largest army

    Args:
        player: The player playing a development card
        card: The development card they are playing
    Raises:
        ValueError: If the player does not have the card
    &#34;&#34;&#34;
    player.play_development_card(card)
    if card is DevelopmentCard.KNIGHT:
        player.number_played_knights += 1
        if player.number_played_knights &gt;= 3 and (
            self.largest_army_owner is None
            or self.largest_army_owner.number_played_knights
            &lt; player.number_played_knights
        ):
            self.largest_army_owner = player</code></pre>
</details>
</dd>
<dt id="katan_ai.katan.game.Game.upgrade_settlement_to_city"><code class="name flex">
<span>def <span class="ident">upgrade_settlement_to_city</span></span>(<span>self, player: <a title="katan_ai.katan.player.Player" href="player.html#katan_ai.katan.player.Player">Player</a>, coords: <a title="katan_ai.katan.board.coords.Coords" href="board/coords.html#katan_ai.katan.board.coords.Coords">Coords</a>, cost_resources: Optional[bool] = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Build a city from a settlement.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player who is building the city</dd>
<dt><strong><code>coords</code></strong></dt>
<dd>Where to build the city</dd>
<dt><strong><code>cost_resources</code></strong></dt>
<dd>Whether to remove the resources from the player's hand</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotEnoughResourcesError</code></dt>
<dd>If cost_resources is true and the player doesn't have enough resources</dd>
<dt><code>ValueError</code></dt>
<dd>If coords is not a valid intersection</dd>
<dt><code>RequiresSettlementError</code></dt>
<dd>If there is not a valid settlement at the intersection to upgrade</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upgrade_settlement_to_city(
    self, player: Player, coords: Coords, cost_resources: Optional[bool] = True
):
    &#34;&#34;&#34;Build a city from a settlement.

    Args:
        player: The player who is building the city
        coords: Where to build the city
        cost_resources: Whether to remove the resources from the player&#39;s hand
    Raises:
        NotEnoughResourcesError: If cost_resources is true and the player doesn&#39;t have enough resources
        ValueError: If coords is not a valid intersection
        RequiresSettlementError: If there is not a valid settlement at the intersection to upgrade
    &#34;&#34;&#34;
    if cost_resources and not player.has_resources(
        BuildingType.CITY.get_required_resources()
    ):
        raise NotEnoughResourcesError(
            &#34;Player does not have the resources to build a city&#34;
        )

    self.board.add_intersection_building(
        player=player, coords=coords, building_type=BuildingType.CITY
    )

    if cost_resources:
        player.remove_resources(BuildingType.CITY.get_required_resources())</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="katan_ai.katan" href="index.html">katan_ai.katan</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="katan_ai.katan.game.Game" href="#katan_ai.katan.game.Game">Game</a></code></h4>
<ul class="">
<li><code><a title="katan_ai.katan.game.Game.add_yield" href="#katan_ai.katan.game.Game.add_yield">add_yield</a></code></li>
<li><code><a title="katan_ai.katan.game.Game.add_yield_for_roll" href="#katan_ai.katan.game.Game.add_yield_for_roll">add_yield_for_roll</a></code></li>
<li><code><a title="katan_ai.katan.game.Game.build_development_card" href="#katan_ai.katan.game.Game.build_development_card">build_development_card</a></code></li>
<li><code><a title="katan_ai.katan.game.Game.build_road" href="#katan_ai.katan.game.Game.build_road">build_road</a></code></li>
<li><code><a title="katan_ai.katan.game.Game.build_settlement" href="#katan_ai.katan.game.Game.build_settlement">build_settlement</a></code></li>
<li><code><a title="katan_ai.katan.game.Game.get_victory_points" href="#katan_ai.katan.game.Game.get_victory_points">get_victory_points</a></code></li>
<li><code><a title="katan_ai.katan.game.Game.move_robber" href="#katan_ai.katan.game.Game.move_robber">move_robber</a></code></li>
<li><code><a title="katan_ai.katan.game.Game.play_development_card" href="#katan_ai.katan.game.Game.play_development_card">play_development_card</a></code></li>
<li><code><a title="katan_ai.katan.game.Game.upgrade_settlement_to_city" href="#katan_ai.katan.game.Game.upgrade_settlement_to_city">upgrade_settlement_to_city</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
